<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于</title>
    <url>/Home/About/</url>
    <content><![CDATA[<h1 id="关于我："><a href="#关于我：" class="headerlink" title="关于我："></a>关于我：</h1><p>永远的空想家。。。</p>
<p>一个河北高一 OIer。虽说从初一就开始学 OI 了，但真正感觉自己在为之努力的奋斗生涯是从高一暑假开始的。</p>
<p>洛谷号：<a href="https://www.luogu.com.cn/user/304572#?">_CloudySky_</a></p>
<p>CF（菜死了）：<a href="https://codeforces.com/profile/_CloudySky_">_CloudySky_</a></p>
<p>偶像名叫 <a href="https://www.luogu.com.cn/user/58705">command_block</a></p>
<p>引用班主任的一段话：<br><img src="/Home/imgs/backgrounds/xct.png" alt=""></p>
<h1 id="关于这个博客："><a href="#关于这个博客：" class="headerlink" title="关于这个博客："></a>关于这个博客：</h1><p>里面的大部分内容还是写给自己的，，默认有一定基础。不过也希望对你能有帮助。</p>
<p>有一些是现学现写的，有些急于求成；也有一些是复习时写的，咕了好久忘差不多了…</p>
<p>里面多少会有一些从其他博客里取过来的经，但最终目的是为了自己掌握。</p>
<p>学习笔记一般格式为：</p>
<p>简介 + 具体实现 + 代码实现</p>
<p>题解一般格式为：</p>
<p>题目大意 + 题目正解 + 题目思路 + 复杂度 + 代码</p>
]]></content>
  </entry>
  <entry>
    <title>玄学建图初步 学习笔记</title>
    <url>/Home/Build-Graph/</url>
    <content><![CDATA[<h1 id="玄学建图初步-学习笔记"><a href="#玄学建图初步-学习笔记" class="headerlink" title="玄学建图初步 学习笔记"></a>玄学建图初步 学习笔记</h1><p>在解决实际问题的时候,有很多情况下一个看似与图论毫无关系的问题,也能通过一些巧妙的做法转化为图论问题。这些问题往往要用特殊的建图方法和一些图论知识来解决.</p>
<span id="more"></span>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>因为最短路松弛操作满足:如果 $D_{u}+ W_{u,v} &lt; D_{v}$ 就更新 $D_{v} = D_{u} + W_{u,v}$ ，即 $D_{v} - D_{u} \leqslant W_{u,v}$，与不等约束条件，如: $X_1-X_2 \leqslant k$ 非常相似。</p>
<p>所以当存在一些点和一些不等条件时,可以转化为 $X_1$ 向 $X_2$ 连一条权值为 $k$ 的边。然后用 $SPAF$ 判断是否存在负环即可。 </p>
<h2 id="2-sat"><a href="#2-sat" class="headerlink" title="2-sat"></a>2-sat</h2><p>当存在一些具有两面性的事物,和一些约束条件,表示某个事物的一个性质和另一个事物的一个性质不能同时存在或必须存在一个时，就可以将每个事物表示成两个点，约束条件连边，用 $tarjan$ 判断代表同一事物的两个点是否在同一连通块中。从而解决问题。</p>
<h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems:"></a>Problems:</h1><ul>
<li><a href="https://cloudyskyet.github.io/Blog/p3275/">P3275 [SCOI2011]糖果</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/p4171/">P4171 [JSOI2010] 满汉全席</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题 学习笔记</title>
    <url>/Home/Bags/</url>
    <content><![CDATA[<h1 id="背包问题-学习笔记"><a href="#背包问题-学习笔记" class="headerlink" title="背包问题 学习笔记"></a>背包问题 学习笔记</h1><p>背包问题是动态规划问题中一类比较基础，偏向格式化的问题。</p>
<span id="more"></span>
<p>动规模型是：有 N 个物品，每个物品有 $v_i$ 的体积和 $w_i$ 的质量，你需要选择任意个物品，使得这些物品的总体积小于背包容量 V，并让 $\sum_{i\in \{bags\}} w_i$ 最大。</p>
<p>背包问题包括几类子问题：01 背包问题，完全背包问题，多重背包问题，混合背包问题等等。</p>
<h2 id="01-背包问题"><a href="#01-背包问题" class="headerlink" title="01 背包问题"></a>01 背包问题</h2><p>时间复杂度：$O(NV)$</p>
<p>01 背包，顾名思义，就是每个物品只有两种状态，选或不选。</p>
<p>具体实现：</p>
<p>不难发现，最基础的动规转移方程就是，$f_{i,j} = \max (f_{i,j}, f_{i-1,j-v[i]}+w_i)$。<br>但是会出现一个问题，这样的空间复杂度是 $O(NV)$ 的。非常难易接受。<br>考虑优化，直接消掉一维，但是显然体积维不能消掉，于是考虑消掉物品维。<br>但这样就出现了一个问题，就是在转移时如果需要用的物品的 $dp$ 数组值已经被<strong>覆盖</strong>了，那么转移出来的答案会是错误的。<br>所以需要更改枚举数序，将体积维<strong>从大到小</strong>枚举，这样每一个可能要用到的状态一定不会被覆盖掉。<br>（因为任何一个物品的体积都为正数，所以一个状态只可能从<strong>比它小</strong>的状态转移过来）</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背包问题 学习笔记</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i ) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = V; j &gt;= v[i]; --j ) &#123;</span><br><span class="line">    f[j] = <span class="built_in">max</span> ( f[j], f[j-v[i]] + w[i] );</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="built_in">printf</span> ( <span class="string">&quot;%d\n&quot;</span>, f[V] );</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>时间复杂度：$O(NV)$</p>
<p>完全背包，就是一个物品可以使用无限次的背包问题。</p>
<p>具体实现：</p>
<p>刚才在进行 01 背包空间优化时发现，如果正序枚举会出选<strong>一个物品用多次</strong>的情况，从而导致结果错误，那么我们在进行多重背包时就可以利用这一点。因为多重背包并不会限制物品个数。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背包问题 学习笔记</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i ) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = v[i]; j &lt;= V; ++j ) &#123;</span><br><span class="line">    f[j] = <span class="built_in">max</span> ( f[j], f[j-v[i]] + w[i] );</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="built_in">printf</span> ( <span class="string">&quot;%d\n&quot;</span>, f[V] );</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>时间复杂度 $O(NVS)$ ~ $O(NV)$</p>
<p>多重背包就是一个物品 i 最多选择 $s_i$ 个的背包。它具有两种常见的优化，二进制拆分和单调队列优化。</p>
<p>具体实现：</p>
<p>可以考虑<strong>在枚举完体积后再枚举个数</strong>。（否则可能会重复使用）</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背包问题 学习笔记</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i ) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j ) &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s[i]; ++k ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( j &lt; k * v[i] ) <span class="keyword">break</span>;</span><br><span class="line">      f[j] = <span class="built_in">max</span> ( f[j], f[j-k*v[i]] + k * w[i] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="built_in">printf</span> ( <span class="string">&quot;%d\n&quot;</span>, f[V] );</span><br></pre></td></tr></table></figure>
<p>单调队列优化：</p>
<p>考虑多重背包的转移方程：</p>
<script type="math/tex; mode=display">f_{u + k * v_i} = \max_{k'}(f_{u + k' * v_i} + (k - k') * w_i)</script><script type="math/tex; mode=display">f_{u + k * v_i} = \max_{k'}(f_{u + k' * v_i} + k * w_i - k' * w_i)</script><script type="math/tex; mode=display">f_{u + k * v_i} = \max_{k'}(f_{u + k' * v_i} - k' * w_i) + k * w_i</script><p>发现多重背包状态转移时 j 只会从 $j - 1 \times v_i , j - 2 \times v_i , j - 3 \times v_i, \dots$ 转移过来。所以就可以将所有的 j 按 $mod (v_i)$分成 $v_i$ 个系。</p>
<p>然后对前面的 $max$ <strong>跑一边单调队列即可</strong>。</p>
<p><a href="https://www.acwing.com/problem/content/6/">AcWing 06</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背包问题 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x, y) f[x &amp; 1][y]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[Maxn], w[Maxn], s[Maxn];</span><br><span class="line"><span class="keyword">int</span> f[Maxn][Maxn], q[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>((i - <span class="number">1</span>), u + k * v[i]) - k * w[i];</span><br><span class="line">  <span class="comment">// 用来计算贡献的函数，这里的 k 其实是上文的 k&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    v[i] = <span class="built_in">read</span>(), w[i] = <span class="built_in">read</span>(), s[i] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = s[i];</span><br><span class="line">    <span class="keyword">if</span> (l &gt; m / v[i]) l = m / v[i];</span><br><span class="line">    <span class="comment">// 判定每个余数系的元素个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; v[i]; ++u) &#123;</span><br><span class="line">    <span class="comment">// 分系跑单调队列。</span></span><br><span class="line">      <span class="keyword">int</span> hd = <span class="number">0</span>, tl = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= (m - u) / v[i]; ++k) &#123;</span><br><span class="line">        <span class="keyword">while</span> (hd &lt;= tl &amp;&amp; <span class="built_in">solve</span>(i, u, q[tl]) &lt;= <span class="built_in">solve</span>(i, u, k))</span><br><span class="line">          tl--;</span><br><span class="line">        <span class="comment">// 弹出劣解元素。</span></span><br><span class="line">        <span class="keyword">if</span> (hd &lt;= t &amp;&amp; q[hd] &lt; k - l) hd++;</span><br><span class="line">        <span class="comment">// 弹出过期元素。</span></span><br><span class="line">        q[++tl] = k;</span><br><span class="line">        <span class="comment">// 当前元素加入队列。</span></span><br><span class="line">        <span class="built_in">f</span>(i, u + k * v[i]) = <span class="built_in">solve</span>(i, u, q[hd]) + k * w[i];</span><br><span class="line">        <span class="comment">// 计算答案，由于是单调的，每个位置只会被更新 1 次，所以不需要取最值。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图基础知识 学习笔记</title>
    <url>/Home/Bipartite-Graph/</url>
    <content><![CDATA[<h1 id="二分图基础知识-学习笔记"><a href="#二分图基础知识-学习笔记" class="headerlink" title="二分图基础知识 学习笔记"></a>二分图基础知识 学习笔记</h1><p>二分图的定义:一个无向图如果满足可以将点集分为两部分，且<strong>每部分之间互相没有连边</strong>，则称这个图为二分图。</p>
<p>二分图的性质：二分图中不存在奇环。</p>
<p>二分图的匹配:一个边的子集且所有点至多出现一次。</p>
<span id="more"></span>
<h2 id="最大匹配"><a href="#最大匹配" class="headerlink" title="最大匹配"></a>最大匹配</h2><p>边最多的匹配。</p>
<p>交错路:一条路径，其中的边是交错的（一条匹配边，一条非匹配边，…）。</p>
<p>增广路:以非匹配点为端点，长度为奇数的交错路。</p>
<p>增广路的性质: </p>
<pre><code>1. 当图中不存在增广路时，此时的匹配为二分图最大匹配。
</code></pre><ol>
<li>将增广路的边的状态翻转可以使最大匹配数 $+1$ 。</li>
</ol>
<h2 id="匈牙利算法求二分图最大匹配"><a href="#匈牙利算法求二分图最大匹配" class="headerlink" title="匈牙利算法求二分图最大匹配"></a>匈牙利算法求二分图最大匹配</h2><p>时间复杂度：$O(nm)$</p>
<p>匈牙利算法就是每次寻找增广路的算法。</p>
<p>具体实现:</p>
<ul>
<li>枚举每一个节点，每次把标记数组清空，以当前节点为根 $dfs$</li>
<li>如果找到一条增广路，就更改之前的匹配并返回 $true$</li>
<li>否则返回 $false$，不做任何修改</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分图基础知识 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> map[<span class="number">1e3</span> + <span class="number">10</span>][<span class="number">1e3</span> + <span class="number">10</span>], flag[<span class="number">1e3</span> + <span class="number">10</span>], mtc[<span class="number">1e3</span> + <span class="number">10</span>];</span><br><span class="line"><span class="comment">//这道题的输入已经将图的点集分好了，所以使用邻接表存图，mtc 数组为当前节点的匹配点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!map[x][i] &amp;&amp; flag[i])  <span class="comment">//如果这两个点之间没有边或当前右部点被访问过，说明当前状态不合法。</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    flag[i] = <span class="number">1</span>;                   <span class="comment">//标记当前右部点被访问过。</span></span><br><span class="line">    <span class="keyword">if</span> (!mtc[i] || <span class="built_in">dfs</span>(mtc[i])) &#123;  <span class="comment">//如果当前右部点没有匹配点，或从当前右部点出发能找到一条增广路，说明当前道路是增广路。</span></span><br><span class="line">      mtc[i] = x;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//更改匹配节点，返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果访问了所有边仍没找到增广路，返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流求解二分图最大匹配"><a href="#网络流求解二分图最大匹配" class="headerlink" title="网络流求解二分图最大匹配"></a>网络流求解二分图最大匹配</h2><p>见 <a href="https://cloudyskyet.github.io/Blog/Flow">Flow</a></p>
<h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><p>当二分图的左右部点数量相同时才会谈完美匹配。<br>完美匹配是所有点都是匹配点的一个匹配。</p>
<p>霍尔定理：对于任何左部点的子集 $s$，与 $s$ 相邻的右部点的数量不小于 $|s|$，则这个二分图存在最大匹配。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>博客索引 &amp;&amp; 留言墙</title>
    <url>/Home/BlogContent/</url>
    <content><![CDATA[<p>上次更新时间：2022-01-13</p>
<h1 id="博客索引-amp-amp-留言墙"><a href="#博客索引-amp-amp-留言墙" class="headerlink" title="博客索引 &amp;&amp; 留言墙"></a>博客索引 &amp;&amp; 留言墙</h1><p>我不认为我有 command-block 的实力，但仍希望可以带来更好的体验。</p>
<p>注：这里文章是按发布时间排序的，博客中按维护时间排序。</p>
<h2 id="图论部分："><a href="#图论部分：" class="headerlink" title="图论部分："></a>图论部分：</h2><p>小结：多数作于初三暑假集训初期，可以算较为全面，但多数质量不高。</p>
<ul>
<li><a href="/Blog/Shortest-Path">最短路算法 学习笔记</a></li>
<li>浅略地写了三种最短路算法，和优缺点，并附上了代码。</li>
<li>题单中为老师要求的题目，解法都比较神奇，由于当时能力有限，所能提供的思路很少。</li>
<li><a href="/Blog/MST">最小生成树 学习笔记</a></li>
<li>简写了两种最小生成树算法的，并附上了代码。</li>
<li>题单中为老师要求的题目，涉及了最小生成树算法 $Kruskal$ 的常见变形，由于当时能力有限，所能提供的思路很少。</li>
<li><a href="/Blog/Euler-Path">欧拉路 学习笔记</a></li>
<li>简介了关于欧拉路和欧拉回路的定义和简单判定，较大篇幅复制的课件。</li>
<li><a href="/Blog/Tarjan/">$\color{red}{\text{Tarjan算法 学习笔记}}$</a></li>
<li>简介了关于有向图强连通分量，无向图点双，边双的定义与等价描述，并附上了 tarjan 算法实现方法和有向图 tarjan 代码。</li>
<li>在 2022 年初进行了维护，或许值得一看。</li>
<li><a href="/Blog/Build-Graph/">玄学建图初步 学习笔记</a></li>
<li>简介了两种常见的建图套路，并附了两道模板题，同样为老师要求的题。</li>
<li><a href="/Blog/Bipartite-Graph/">二分图基础知识 学习笔记</a></li>
<li>介绍了二分图的一些简单概念与性质与匈牙利二分图匹配算法。</li>
<li><a href="/Blog/Topo/">拓扑排序 学习笔记</a></li>
<li>介绍了拓扑排序的基础实现。</li>
<li><a href="/Blog/Flow/">$\color{red}{\text{网络流及 Dinic,EK 学习笔记}}$</a></li>
<li>介绍了网络流的基本知识和两种常用的网络流实现算法。</li>
<li>或许值得一看</li>
<li>但限于水平问题，只附了板子，对最精髓的建图方面只字未提。</li>
</ul>
<h2 id="字符串部分："><a href="#字符串部分：" class="headerlink" title="字符串部分："></a>字符串部分：</h2><ul>
<li><a href="/Blog/String/">字符串基础 学习笔记</a></li>
<li>只有一篇，成篇于暑假初期，介绍了几种字符串算法，涉及回文串，字符串匹配。</li>
<li>进行过一定维护。</li>
</ul>
<h2 id="数据结构部分："><a href="#数据结构部分：" class="headerlink" title="数据结构部分："></a>数据结构部分：</h2><p>小结：可能写的比较零散，没有进行过专项。</p>
<ul>
<li><a href="/Blog/Tree-Trie/">字典树 学习笔记</a></li>
<li>成篇于暑假初期。介绍了 $Trie$ 树的几种应用，涉及字符串，异或操作和平衡树。</li>
<li><a href="/Blog/FHQ-Treap/">$\color{red}{\text{FHQ_Treap 学习笔记}}$</a></li>
<li>介绍了 $FHQ_Treap$ 并附上了代码，有一定可读性。</li>
<li><a href="/Blog/Segment-Tree/">$\color{red}{\text{线段树，可持久化权值线段树，树套树 学习笔记}}$</a></li>
<li>较详细地介绍了线段树和常见变形，对基础要求低。</li>
<li><a href="/Blog/p1972/">P1972 [SDOI2009]HH的项链</a></li>
<li>可持久化线段树的一道例题。</li>
</ul>
<h2 id="数学部分："><a href="#数学部分：" class="headerlink" title="数学部分："></a>数学部分：</h2><p>小结：大部分是一些零碎的算法的学习笔记。多数作于高一刚开学时。</p>
<ul>
<li><a href="/Blog/Cantor">康托展开 学习笔记</a></li>
<li>介绍了康托展开算法，附上了板子。</li>
<li><a href="/Blog/exgcd-0">$\color{red}{\text{拓展欧几里得算法（exgcd） 学习笔记}}$</a></li>
<li>较详细地介绍了扩展欧几里得算法。</li>
<li><a href="/Blog/CRT/">中国剩余定理（CRT）及 Excrt 学习笔记</a></li>
<li>介绍了中国剩余定理和扩展中国剩余定理算法，并附上了板子。</li>
<li><a href="/Blog/Matrix/">$\color{red}{\text{矩阵 学习笔记}}$</a></li>
<li>较系统地介绍了矩阵基础知识和应用，进行过多次维护。</li>
<li><a href="/Blog/HOCE/">求解高次同余方程（离散对数） 学习笔记</a></li>
<li>介绍了离散对数和 BSGS 算法的实现。</li>
<li><a href="/Blog/Game-Theory/">博弈论初步基础知识 学习笔记</a></li>
<li>介绍了博弈论基础知识。</li>
<li><a href="/Blog/Combinatorial-Mathematics/">组合数学基础知识 学习笔记</a></li>
<li>一个半路弃掉的坑。介绍了排列组合的一些性质。</li>
<li><a href="/Blog/Number-Theory/">$\color{red}{\text{数论初步 学习笔记}}$</a></li>
<li>介绍了数论初步知识，欧拉函数和莫比乌斯函数的性质和简单应用。关于约数方面还有待完善。</li>
<li><a href="/Blog/Polynomial/">$\color{red}{\text{多项式 学习笔记}}$</a></li>
<li>多项式基础知识，多项式<strong>半家桶</strong>。但写了的部分应该挺详细。</li>
</ul>
<h2 id="动态规划部分"><a href="#动态规划部分" class="headerlink" title="动态规划部分"></a>动态规划部分</h2><p>小结：高中之前动态规划一直特别弱，所以写的都是一些简单题的题解，加速理解。</p>
<ul>
<li><a href="http://localhost:4000/Blog/Bags/">$\color{red}{\text{背包问题 学习笔记}}$</a></li>
<li>少有的成系统的学习笔记，介绍了常见背包模板。</li>
<li><a href="/Blog/p1868/">P1868 饥饿的奶牛</a></li>
<li>一道简单的线性 DP</li>
<li><a href="/Blog/p5020/">P5020 [NOIP2018 提高组] 货币系统</a></li>
<li>一道简单的背包 DP</li>
<li><a href="/Blog/p5322/">P5322 [BJOI2019]排兵布阵</a></li>
<li>一道简单的线性 DP</li>
<li><a href="/Blog/p3558/">P3558 [POI2013]BAJ-Bytecomputer</a></li>
<li>一道简单的线性 DP</li>
<li><a href="/Blog/p4302/">P4302 [SCOI2003]字符串折叠</a></li>
<li>一道简单的区间 DP</li>
</ul>
<h2 id="分治部分："><a href="#分治部分：" class="headerlink" title="分治部分："></a>分治部分：</h2><p>小结：目前只有两篇，在 2021 年末成篇。</p>
<ul>
<li><a href="/Blog/CDQ/">CDQ分治 学习笔记</a></li>
<li>简介了 $CDQ$ 分治算法，应用方面有待完善。</li>
<li><a href="/Blog/Overall-Dichotomy/">$\color{red}{\text{整体二分 学习笔记}}$</a></li>
<li>简介了整体二分算法，较为全面。</li>
</ul>
<h2 id="一些综合性题解或杂项（不再标注）"><a href="#一些综合性题解或杂项（不再标注）" class="headerlink" title="一些综合性题解或杂项（不再标注）"></a>一些综合性题解或杂项（不再标注）</h2><ul>
<li><a href="/Blog/NOIP2021/">NOIP2021 游记及题解</a></li>
<li>浅述我的 NOIP2021 学习（划水）经历\NOIP T1-T3 题解</li>
<li><a href="/Blog/solution-2021-10-21/">2021-10-21 CSP 考前模拟赛题解</a></li>
<li><a href="/Blog/solution-2021-12-12/">2021-12-12 模拟赛总结</a></li>
<li><a href="/Blog/solution-2021-12-26/">2021-12-26 模拟赛总结</a></li>
</ul>
<h2 id="技术流？"><a href="#技术流？" class="headerlink" title="技术流？"></a>技术流？</h2><ul>
<li><a href="/Blog/hexo/">Hexo 博客搭建教程</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>CDQ分治 学习笔记</title>
    <url>/Home/CDQ/</url>
    <content><![CDATA[<h1 id="CDQ-分治-学习笔记"><a href="#CDQ-分治-学习笔记" class="headerlink" title="CDQ 分治 学习笔记"></a>CDQ 分治 学习笔记</h1><p>CDQ 分治是 OI 中一个比较常用的分治算法。模板的实现较为简单，重点在于领会思想。</p>
<span id="more"></span>
<h2 id="CDQ-分治用来解决点对三维偏序问题"><a href="#CDQ-分治用来解决点对三维偏序问题" class="headerlink" title="CDQ 分治用来解决点对三维偏序问题"></a>CDQ 分治用来解决点对三维偏序问题</h2><p>点对的三位偏序可以表示为</p>
<p>有 $n$ 个元素，第 $i$ 个元素有 $a_i,b_i,c_i$ 三个属性，设 $f(i)$ 表示满足 $a_j \leq a_i$ 且 $b_j \leq b_i$ 且 $c_j \leq c_i$ 且 $j \ne i$ 的 $j$ 的数量。求 $f_{i}$ 。</p>
<p>先假设没有相同的元素，具体实现：</p>
<ul>
<li>将整个数组按照 $a_i$ 排序，开始递归。</li>
<li>将当前区间二分，左右两边<strong>分别</strong>按照 $b_i$ 排序。</li>
</ul>
<p>现在考虑左边的所有数字 $a_i$ 一定小于右边，这是在分治开始之前就已经确定好的。</p>
<p>然后由于你在左右分别按照第二维排序了，所以第二维也分别是有序的。</p>
<ul>
<li><p>所以就可以在左右分别维护一个指针 $pl, pr$ 。</p>
</li>
<li><p>枚举 $pr \in[mid + 1, r]$ 。</p>
</li>
<li><p>跳 $pl\in[l, mid]$ 使 $b_{pl} &lt; b_{pr}$ 始终成立，同时将已经扫过的 $c_{pl}$ <strong>插入树状数组</strong>。</p>
</li>
<li><p>每次当 $pl$ 不能再跳时统计 $pr$ 贡献 $ans_{pr} += ask (c_{pr})$ ，即第三维也比当前数字小的数。</p>
</li>
<li>枚举 $i\in[l, pl]$ ，在树状数组上消除贡献。</li>
</ul>
<p>由于你的前两维已经确定了，所以只要第三维也比当前数小的话，就一定满足条件。</p>
<p>由于以上整个过程都处于分治过程中，所以一定可以保证不重不漏。</p>
<p>另外，如果要在递归之前排序的话，一定要建<strong>临时数组</strong>，否则递归回出错；</p>
<p>也可以先递归，然后进行操作，最后将<strong>当前整段区间</strong>进行排序，以便<strong>父层</strong>使用，最后分治完再将序列<strong>排回原样</strong>。</p>
<p>两种写法更推荐后者，排序没有过多的复杂度浪费。</p>
<p><a href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CDQ 分治 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp; -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt;= Maxn; x += <span class="built_in">lowbit</span>(x)) </span><br><span class="line">    v[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span> (x)) </span><br><span class="line">    ans += v[x];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> x, y, z, f;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x != b.x) <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    <span class="keyword">if</span> (y != b.y) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">    <span class="keyword">if</span> (z != b.z) <span class="keyword">return</span> z &lt; b.z;</span><br><span class="line">    <span class="keyword">return</span> f &lt; b.f;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> node b) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x != b.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (y != b.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (z != b.z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(node &amp;n, node &amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n.y != m.y) <span class="keyword">return</span> n.y &lt; m.y;</span><br><span class="line">  <span class="keyword">return</span> n.z &lt; m.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[Maxn], n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">solve</span> (l, mid), <span class="built_in">solve</span> (mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="keyword">int</span> pos1 = l, pos2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; pos2 &lt;= r; ++pos2) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[pos1].y &lt;= a[pos2].y &amp;&amp; pos1 &lt;= mid) &#123;</span><br><span class="line">      <span class="built_in">add</span> (a[pos1].z, <span class="number">1</span>), pos1 ++;</span><br><span class="line">    &#125;</span><br><span class="line">    a[pos2].f += <span class="built_in">ask</span> (a[pos2].z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; pos1; ++i) &#123;</span><br><span class="line">    <span class="built_in">add</span> (a[i].z, <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (a + l, a + r + <span class="number">1</span>, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span> (), k = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    a[i] = (node) &#123;<span class="built_in">read</span> (), <span class="built_in">read</span> (), <span class="built_in">read</span> ()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">solve</span> (<span class="number">1</span>, n);</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> lst = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == a[lst]) a[i].f = a[lst].f;</span><br><span class="line">    <span class="keyword">else</span> lst = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    d[a[i].f] ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">print</span> (d[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>D&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理（CRT）及 Excrt 学习笔记</title>
    <url>/Home/CRT/</url>
    <content><![CDATA[<h1 id="中国剩余定理（CRT）及-Excrt-学习笔记"><a href="#中国剩余定理（CRT）及-Excrt-学习笔记" class="headerlink" title="中国剩余定理（CRT）及 Excrt 学习笔记"></a>中国剩余定理（CRT）及 Excrt 学习笔记</h1><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>时间复杂度：$O(nlogn)$</p>
<p>中国剩余定理是用来解形如</p>
<script type="math/tex; mode=display">x \equiv a_1(\mod m_1)</script><script type="math/tex; mode=display">x \equiv a_2(\mod m_2)</script><script type="math/tex; mode=display">x \equiv a_3(\mod m_3)</script><script type="math/tex; mode=display">\dots</script><script type="math/tex; mode=display">x \equiv a_k(\mod m_k)</script><p>保证 $m_1,m_2,\dots m_k$ 互质</p>
<p>的同余方程的最小整数解的算法。</p>
<span id="more"></span>
<p>具体实现：<br>设 $M=\prod_{i=1}^n m_i$，$M_i = M / m_i$，$M_iT_i \equiv 1(\mod m_i)$ 。（即 $T_i$ 是 $M_i$ 在模 p 意义下的逆元）<br>则其中的一种特解为：$ans = \sum_{i=1}^n a_i \times M_i \times T_i$，最小整数解即为 $ans \mod M$ 。</p>
<p>证明：</p>
<script type="math/tex; mode=display">\because M_i = M / m_i</script><script type="math/tex; mode=display">\therefore \forall j\in[1,k],\text当 i ≠ j \text{时，}a_jM_jT_j \equiv 0(\mod m_i)</script><script type="math/tex; mode=display">\text当 i = j \text{时，}a_iM_iT_i \equiv a_i(\mod m_i)</script><script type="math/tex; mode=display">\therefore \sum_{i=1}^ka_iM_iT_i\equiv a_i(\mod m_i)\text{满足题意}</script><p><a href="https://www.luogu.com.cn/problem/P1495">P1495 [模板]中国剩余定理(CRT)/曹冲养猪</a><br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中国剩余定理（CRT）及 Excrt 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[Maxn], m[Maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Mi[Maxn], t[Maxn], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ll tx, ty;</span><br><span class="line">  <span class="built_in">exgcd</span>(b, a % b, tx, ty);</span><br><span class="line">  x = ty, y = tx - a / b * ty;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  ll M = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;m[i], &amp;a[i]);</span><br><span class="line">    M *= <span class="number">1ll</span> * m[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    Mi[i] = M / (<span class="number">1ll</span> * m[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ll y;</span><br><span class="line">    <span class="built_in">exgcd</span>(Mi[i], m[i], t[i], y);</span><br><span class="line">    t[i] = (t[i] % m[i] + m[i]) % m[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ans += a[i] * Mi[i] * t[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans % M);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="updated-2021-09-14"><a href="#updated-2021-09-14" class="headerlink" title="updated: 2021-09-14"></a>updated: 2021-09-14</h1><h2 id="拓展中国剩余定理（Excrt）"><a href="#拓展中国剩余定理（Excrt）" class="headerlink" title="拓展中国剩余定理（Excrt）"></a>拓展中国剩余定理（Excrt）</h2><p>时间复杂度：$O(nlogn)$</p>
<p>拓展中国剩余定理这个名字我认为不很恰当，因为算法的实现思路和思维含量完全不同，仅仅是因为解决的问题类似。</p>
<p>Excrt 所能解决 m 并不互质的同余方程组。核心思路是将方程组一一合并（即构造出一个同余方程等效于同时满足两个同余方程），到最后剩下的便是答案。</p>
<p>具体实现：</p>
<p>首先思考如何合并两个方程组：</p>
<p>$x \equiv a_1(\mod m_1)$</p>
<p>$x \equiv a_2(\mod m_2)$</p>
<p>先把它化为标准形式</p>
<p>$x = a_1 + k_1 \times m_1 = a_2 + k_2 \times m_2$</p>
<p>然后把它移项，变成：</p>
<p>$k_1 m_1 - k_2  m_2 = a_2 - a_1$</p>
<p>这样就是一个标准的一元二次不定方程，所以就可以判断无解情况，即 $( a_2 - a_1 ) | gcd ( m_1, m_2 )$ 不成立。</p>
<p>然后解出来 $k_1 , k_2$ 。</p>
<p>合并后的方程组就变成了 $x \equiv a_1 + k_1 \times m_1 \times ( a_2 - a_1 ) / gcd ( m_1, m_2 )  ( \mod lcm ( m_1, m_2 ) )$</p>
<p>接下来只需要依次合并方程组就可以了。</p>
<p>注意：在合并第 $n - 1$ 和第 $n$ 个方程时，要将 $a_{n-1}$ 和 临时的解对 $m_n$ 取模，来保证方程的正确性。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中国剩余定理（CRT）及 Excrt 学习笔记</span></span><br><span class="line"><span class="keyword">namespace</span> Excrt &#123;</span><br><span class="line"></span><br><span class="line">ll a1, m1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(ll a2, ll m2)</span> </span>&#123;</span><br><span class="line">  ll x, y;</span><br><span class="line">  ll g = <span class="built_in">exgcd</span>(m1, m2, x, y);</span><br><span class="line">  ll c = (a2 - a1 % m2 + m2) % m2;</span><br><span class="line">  <span class="keyword">if</span> (c % g) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  ll lcm = m1 / g * m2;</span><br><span class="line">  x = <span class="built_in">mul</span>(x, c / g, m2);</span><br><span class="line">  a1 += x * m1, a1 %= lcm;</span><br><span class="line">  a1 = (a1 + lcm) % lcm;</span><br><span class="line">  m1 = lcm;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Excrt</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Excrt;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P4777">P4777 [模板]扩展中国剩余定理（EXCRT）</a><br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中国剩余定理（CRT）及 Excrt 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[Maxn], m[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll&amp; x, ll&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  ll tx, ty, g = <span class="built_in">exgcd</span>(b, a % b, tx, ty);</span><br><span class="line">  x = ty, y = tx - a / b * ty;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll mod)</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = (a &lt;&lt; <span class="number">1</span>) % mod) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans + a) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Excrt &#123;</span><br><span class="line"></span><br><span class="line">ll a1, m1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(ll a2, ll m2)</span> </span>&#123;</span><br><span class="line">  ll x, y;</span><br><span class="line">  ll g = <span class="built_in">exgcd</span>(m1, m2, x, y);</span><br><span class="line">  ll c = (a2 - a1 % m2 + m2) % m2;</span><br><span class="line">  <span class="keyword">if</span> (c % g) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">  ll lcm = m1 / g * m2;</span><br><span class="line">  x = <span class="built_in">mul</span>(x, c / g, m2);</span><br><span class="line">  a1 += x * m1, a1 %= lcm;</span><br><span class="line">  a1 = (a1 + lcm) % lcm;</span><br><span class="line">  m1 = lcm;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Excrt</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;m[i], &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  Excrt::a1 = a[<span class="number">1</span>], Excrt::m1 = m[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!Excrt::<span class="built_in">Insert</span>(a[i], m[i])) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (Excrt::a1 + Excrt::m1) % Excrt::m1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>康托展开 学习笔记</title>
    <url>/Home/Cantor/</url>
    <content><![CDATA[<h1 id="康托展开-学习笔记"><a href="#康托展开-学习笔记" class="headerlink" title="康托展开 学习笔记"></a>康托展开 学习笔记</h1><p>时间复杂度：$O(nlogn)$</p>
<p>康托展开（狭义）以及逆康托展开是指排列和阶乘进制数（即当前排列的字典序排名）进行转化的算法。</p>
<span id="more"></span>
<p>具体实现：</p>
<ul>
<li>维护一个数据结构线段树或树状数组，用来维护未被选择的、比当前数字小的数的个数。</li>
<li>设到第 $i$ 位未被选择的、比当前数字小的数的个数为 $a_i$。则：<br>$ans = \sum_{i=1}^n a_i \times (n-i)! + 1$</li>
</ul>
<p>理解一下这个式子：当前面几位定好之后，这个排列的排名就只与比当前位小且还未被选择的数的个数有关。</p>
<p>例如：排列 1 2 5 4 3 答案便是 $0 \times 4! + 0 \times 3! + 2 \times 2! + 1\times 1 + 0 + 1 = 6$ 。</p>
<ul>
<li><p>统计每一位答案并在树上修改。</p>
</li>
<li><p>逆康托展开与之相反，且要求康托展开统计答案时用数组模拟阶乘进制数。</p>
</li>
<li>从后往前扫，在线段树上二分查找，有 $a_i$ 个比它小且使用过的数的数。（即排名为 $a_i + 1$ 的数）</li>
<li>统计每一位答案并在树上修改。</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/U72177">U72177 火星人plus</a>：</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 康托展开 x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, p[Maxn], x[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> dat;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].dat</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(ls, l, mid),</span><br><span class="line">    <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    ans += <span class="built_in">ask</span>(ls, l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    ans += <span class="built_in">ask</span>(rs, l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) += k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">    <span class="built_in">add</span>(ls, v, k);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">add</span>(rs, v, k);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">l</span>(p);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">v</span>(ls) &gt;= k)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(ls, k);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(rs, k - <span class="built_in">v</span>(ls));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Segment_tree</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segment_tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;p[i]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    x[i] = <span class="built_in">ask</span>(<span class="number">1</span>, <span class="number">1</span>, p[i]),</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, p[i], <span class="number">1</span>);</span><br><span class="line">  x[<span class="number">1</span>] += m;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i] &lt; i) <span class="keyword">break</span>;</span><br><span class="line">    x[i + <span class="number">1</span>] += x[i] / i;</span><br><span class="line">    x[i] %= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    p[i] = <span class="built_in">find</span>(<span class="number">1</span>, x[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, p[i], <span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, p[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学基础知识 学习笔记</title>
    <url>/Home/Combinatorial-Mathematics/</url>
    <content><![CDATA[<h1 id="组合数学基础知识-学习笔记"><a href="#组合数学基础知识-学习笔记" class="headerlink" title="组合数学基础知识 学习笔记"></a>组合数学基础知识 学习笔记</h1><h1 id="一个半路弃掉的坑"><a href="#一个半路弃掉的坑" class="headerlink" title="一个半路弃掉的坑"></a>一个半路弃掉的坑</h1><p>组合数学是 OI 数学中的一个重要分支。在 OI 中有很多用途。具体包含排列，组合，以及衍生出来的特殊排列组合，和一些特殊的依托于组合数数列，如：卡特兰树，斯特林数等以及一些计数问题。</p>
<span id="more"></span>
<h2 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h2><p>排列组合是组合数学的基础。</p>
<h3 id="排列组合公式"><a href="#排列组合公式" class="headerlink" title="排列组合公式"></a>排列组合公式</h3><p>组合：$C^m_n$ 代表从 n 个数中选出 m 个元素组成集合。</p>
<p>例：从 4 个数里选出 3 个数组成集合。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 2 4</span><br><span class="line">1 3 4</span><br></pre></td></tr></table></figure><br>多举几个例子就会发现：</p>
<script type="math/tex; mode=display">C_n^m(\text{也可以写作}(^n_m))=\frac{n!}{(n-m)!m!}</script><p>排列：$P^m_n$ 代表从 n 个数中选出 m 个元素组成排列（排列是有序的）。</p>
<p>例：仍然从 4 个数里选出 3 个数，组成排列<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br><span class="line">1 2 4</span><br><span class="line">1 4 2</span><br><span class="line">2 1 4</span><br><span class="line">2 4 1</span><br><span class="line">4 1 2</span><br><span class="line">4 2 1</span><br><span class="line">1 3 4</span><br><span class="line">1 4 3</span><br><span class="line">3 1 4</span><br><span class="line">3 4 1</span><br><span class="line">4 1 3</span><br><span class="line">4 3 1</span><br></pre></td></tr></table></figure><br>可以总结成两步，先选出 m 个数，有 $C_n^m$ 种结果，然后全排列，有 $m!$ 种结果，所以最后的公式就是：</p>
<script type="math/tex; mode=display">P^m_n=\frac{n!}{(n-m)!}</script><p>圆排列：</p>
<p>圆排列就是增加了循环同构的性质，即 1 2 3 和 2 3 1 是一样的。结论也很简单 $P_n^{m’}=\frac{P_n^m}{m}$ ,即 $p_n^m=\frac{n!}{(n-m)!m}$</p>
<p>全错位排列：</p>
<p>满足 $\forall i \in [1,n], p_i \ne i$ 的排列叫做全错位排列。</p>
<script type="math/tex; mode=display">P_i=\begin{cases} 0&i=1\\ 1&i=2\\ (n-1)(P_{n-1}+P_{n-2})&i\ge 3\end{cases}</script><h3 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h3><script type="math/tex; mode=display">(x+a)=\sum ^n_{k=0}C_n^k \times x^k\times a^{n-k}</script><p>一个简单应用 </p>
<script type="math/tex; mode=display">\sum^n_{k=0}C_n^k=2^n</script><p>证明：$(1+1)^n=\sum^n_{k=0}C_n^k=2^n$</p>
<h3 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="Lucas 定理"></a>Lucas 定理</h3><script type="math/tex; mode=display">C_n^m \mod p=C_{n/p}^{m/p}\times C_{n \mod p}^{m \mod p} \mod p</script><p>一般用来化简项数过高的组合数。</p>
<h2 id="特殊数列及应用"><a href="#特殊数列及应用" class="headerlink" title="特殊数列及应用"></a>特殊数列及应用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To be continued</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉路 学习笔记</title>
    <url>/Home/Euler-Path/</url>
    <content><![CDATA[<h1 id="欧拉路-学习笔记"><a href="#欧拉路-学习笔记" class="headerlink" title="欧拉路 学习笔记"></a>欧拉路 学习笔记</h1><p>欧拉路本质上是一笔画问题的延伸，具有欧拉路的图有很多性质，具体如下：</p>
<span id="more"></span>
<ul>
<li>无向图欧拉路：<br>  有且仅有 $2$ 个点度数为奇数，其余点度均为偶数；或所有点数均为偶数（欧拉回路）</li>
<li>有向图欧拉路：<ol>
<li>除去起点和终点，所有店的入度和出度均相等。</li>
<li>起点出度比入度大 $1$，终点入度比出度大 $1$；或起点终点出入度相同（欧拉回路）</li>
</ol>
</li>
</ul>
<h2 id="判定欧拉路"><a href="#判定欧拉路" class="headerlink" title="判定欧拉路"></a>判定欧拉路</h2><p>判断一张图是否为欧拉路一般要靠 $dfs$ 实现，最后扫一遍是否有边未访问过。</p>
<p>时间复杂度:$O(n+m)$</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 欧拉路 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;  <span class="comment">//枚举每一条边</span></span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;  <span class="comment">//判断是否走过</span></span><br><span class="line">    vis[y] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);  <span class="comment">//如果没走过就走</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hierholzer算法判定欧拉回路"><a href="#Hierholzer算法判定欧拉回路" class="headerlink" title="Hierholzer算法判定欧拉回路"></a>Hierholzer算法判定欧拉回路</h3><p>时间复杂度: $O(n+m)$</p>
<p>具体实现：</p>
<ul>
<li>选择任意顶点为起点，遍历所有相邻边。</li>
<li>深搜，访问所有相邻节点，将经过的边都删除。</li>
<li>如果当前顶点没有相临边，则将当前顶点入栈。</li>
<li>栈中的顶点倒序输出，则是从起点出发的欧拉回路。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 欧拉路 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> val[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> stc[Maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!val[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    val[i] = val[i ^ <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y);</span><br><span class="line">  &#125;</span><br><span class="line">  stc[++top] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>FHQ_Treap 学习笔记</title>
    <url>/Home/FHQ-Treap/</url>
    <content><![CDATA[<h1 id="FHQ-Treap-学习笔记"><a href="#FHQ-Treap-学习笔记" class="headerlink" title="FHQ_Treap 学习笔记"></a>FHQ_Treap 学习笔记</h1><p>时间复杂度：$O(nlogn)$</p>
<p>$FhqTreap$ 是一种 $Treap$ 的变形，他摒弃了传统平衡树的旋转操作，取而代之的，是分裂和合并操作。具体而言一共包含 $3$ 种函数： 按权值分裂，按大小分裂和启发式合并操作，其中按大小分裂可以直接退化为非递归形式且不改变树的结构，类似线段树上二分，找到第 $k$ 大的数。平衡树的操作都可以转变为这几种操作的组合。要维护的信息和普通的 $Treap$ 基本一致，随即键值来保证树的结构的思想也如出一辙。</p>
<span id="more"></span>
<p>具体实现：</p>
<ol>
<li>插入操作：读入一个数 $x$ ，将 $x$ 放入平衡树中。可以转变先按 $x$ 将树分裂为左右两棵树 $a$ 和 $b$，先将 $a$ 和 $x$ 合并，再将合并后的树与 $b$ 合并。</li>
<li>（个人认为最难理解）删除操作：读入一个数 $x$， 删除平衡树中第一个权值为 $x$ 的点。可以转变为先按 $x$ 分裂为左右两棵子树 $a, b$，再将 $a$ 按 $x - 1$ 分裂为 $a, c$，最后先将 $c$ 的左右子树合并再与 $a, b$ 合并。原因：可能有多个相同的值，而只需要删除一个，在这些权值相同的数中，最好找的就是根节点，所以直接删除根节点即可。</li>
<li>查询排名操作：按 $x - 1$ 分裂，左子树的大小 $+ 1$ 就是 $x$ 的排名。（因为可能存在重复数字，所以不能直接按 $x$ 分裂）</li>
<li>按照排名找数：直接调用函数即可。 </li>
<li>查前驱操作：先按 $x$ 分裂为 $a, b$，再将 $a$ 按 $x - 1$ 分裂，或按 $a$ 子树大小分裂，右子树即为所求（注意求出答案后要先把 $a$ 重新合并好，再将 $a, b$ 合并起来）。</li>
<li>查后继操作：与前驱类似，先按 $x$ 分裂为 $a, b$，再将 $b$ 按 $x + 1$ 分裂，或按 $1$ 大小分裂，左子树即为所求。</li>
</ol>
<p>代码实现：</p>
<ol>
<li>分裂函数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FHQ_Treap 学习笔记</span></span><br><span class="line"><span class="comment">// 将 p 按照 val 分裂为 a 子树和 b 子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splite</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;a = b = <span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">v</span>(p) &lt;= val)  <span class="comment">// 说明 val 在右子树上，递归右子树</span></span><br><span class="line">    a = p, <span class="built_in">splite</span> (<span class="built_in">rs</span>(p), val, <span class="built_in">rs</span>(p), b);</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">// 否则递归左子树</span></span><br><span class="line">    b = p, <span class="built_in">splite</span> (<span class="built_in">ls</span>(p), val, a, <span class="built_in">ls</span>(p));</span><br><span class="line">  <span class="built_in">push_up</span> (p);  <span class="comment">// 因为树的形态被改变，所以记着上传信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>按大小分裂函数的变形：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FHQ_Treap 学习笔记</span></span><br><span class="line"><span class="comment">// 变形后的函数并不会真的改变树的结构，与线段树的二分查找类似，返回值是权值第 k + 1 大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) &gt;= k)  <span class="comment">//要 找的值在左子树上</span></span><br><span class="line">      p = <span class="built_in">ls</span>(p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) + <span class="number">1</span> == k)  <span class="comment">// 找到了</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 要找的值在右子树上，说明左子树以及根上的值都比要找的值小，k - (sz(ls) + 1)，在右子树上找</span></span><br><span class="line">      k -= <span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) + <span class="number">1</span>;</span><br><span class="line">      p = <span class="built_in">rs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>启发式合并函数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FHQ_Treap 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a || !b) &#123;<span class="keyword">return</span> a | b;&#125;</span><br><span class="line">  <span class="comment">// d 为随机权值来保证树的结构</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">d</span>(a) &lt; <span class="built_in">d</span>(b)) &#123;  <span class="comment">// 应该接在右子树上</span></span><br><span class="line">    <span class="built_in">rs</span>(a) = <span class="built_in">merge</span> (<span class="built_in">rs</span>(a), b);</span><br><span class="line">    <span class="built_in">push_up</span> (a); <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">// 应该接在左子树上</span></span><br><span class="line">    <span class="built_in">ls</span>(b) = <span class="built_in">merge</span> (a, <span class="built_in">ls</span>(b));</span><br><span class="line">    <span class="built_in">push_up</span> (b); <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>六种操作：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FHQ_Treap 学习笔记</span></span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;  <span class="comment">// 插入操作，先按照 x 分裂，插入节点后启发式合并。</span></span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (a, <span class="built_in">insert</span> (x)), b);</span><br><span class="line"><span class="comment">// 这里相当于把代码压缩了一下，相当于 t = merge (a, insert (x)), root = merge (t, b)</span></span><br><span class="line">    &#125; <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;  <span class="comment">// 删除操作，按照上文。</span></span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      <span class="built_in">splite</span> (a, x - <span class="number">1</span>, a, c);</span><br><span class="line">      c = <span class="built_in">merge</span> (<span class="built_in">ls</span>(c), <span class="built_in">rs</span>(c));</span><br><span class="line">      root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (a, c), b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;  <span class="comment">// 查询排名。</span></span><br><span class="line">      <span class="built_in">splite</span> (root, x - <span class="number">1</span>, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sz</span>(a) + <span class="number">1</span>);</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">4</span>) &#123;  <span class="comment">// 按照排名找数直接查就行了。</span></span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span>(root, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">5</span>) &#123;  <span class="comment">// 找前驱，这里用的是先按权值再按大小分裂。</span></span><br><span class="line">      <span class="built_in">splite</span> (root, x - <span class="number">1</span>, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span> (a, <span class="built_in">sz</span>(a)));</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">6</span>) &#123;  <span class="comment">// 同上。</span></span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span> (b, <span class="number">1</span>));</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3369">P3369 [模板]普通平衡树</a>:</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FHQ_Treap 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> IO</span><br><span class="line"><span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Treap</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, val, dat, siz;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) T[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) T[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> v(x) T[x].val</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> d(x) T[x].dat</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> sz(x) T[x].siz</span></span><br><span class="line">&#125; T[Maxn]; <span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span> <span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = ++tot;</span><br><span class="line">  <span class="built_in">ls</span>(p) = <span class="built_in">rs</span>(p) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">d</span>(p) = <span class="built_in">rand</span> ();</span><br><span class="line">  <span class="built_in">v</span>(p) = val, <span class="built_in">sz</span>(p) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sz</span>(p) = <span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) + <span class="built_in">sz</span>(<span class="built_in">rs</span>(p)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splite</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) &#123;a = b = <span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">v</span>(p) &lt;= val)</span><br><span class="line">    a = p, <span class="built_in">splite</span> (<span class="built_in">rs</span>(p), val, <span class="built_in">rs</span>(p), b);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    b = p, <span class="built_in">splite</span> (<span class="built_in">ls</span>(p), val, a, <span class="built_in">ls</span>(p));</span><br><span class="line">  <span class="built_in">push_up</span> (p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!a || !b) &#123;<span class="keyword">return</span> a | b;&#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">d</span>(a) &lt; <span class="built_in">d</span>(b)) &#123;</span><br><span class="line">    <span class="built_in">rs</span>(a) = <span class="built_in">merge</span> (<span class="built_in">rs</span>(a), b);</span><br><span class="line">    <span class="built_in">push_up</span> (a); <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">ls</span>(b) = <span class="built_in">merge</span> (a, <span class="built_in">ls</span>(b));</span><br><span class="line">    <span class="built_in">push_up</span> (b); <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) &gt;= k) &#123;</span><br><span class="line">      p = <span class="built_in">ls</span>(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) + <span class="number">1</span> == k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      k -= <span class="built_in">sz</span>(<span class="built_in">ls</span>(p)) + <span class="number">1</span>;</span><br><span class="line">      p = <span class="built_in">rs</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> opt = <span class="built_in">read</span> (), x = <span class="built_in">read</span> (), a, b, c;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (a, <span class="built_in">insert</span> (x)), b);</span><br><span class="line">    &#125; <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      <span class="built_in">splite</span> (a, x - <span class="number">1</span>, a, c);</span><br><span class="line">      c = <span class="built_in">merge</span> (<span class="built_in">ls</span>(c), <span class="built_in">rs</span>(c));</span><br><span class="line">      root = <span class="built_in">merge</span> (<span class="built_in">merge</span> (a, c), b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">splite</span> (root, x - <span class="number">1</span>, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">sz</span>(a) + <span class="number">1</span>);</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span>(root, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="built_in">splite</span> (root, x - <span class="number">1</span>, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span> (a, <span class="built_in">sz</span>(a)));</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">6</span>) &#123;</span><br><span class="line">      <span class="built_in">splite</span> (root, x, a, b);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">find</span> (b, <span class="number">1</span>));</span><br><span class="line">      root = <span class="built_in">merge</span> (a, b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Data-Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流及 Dinic,EK 学习笔记</title>
    <url>/Home/Flow/</url>
    <content><![CDATA[<h1 id="网络流及-Dinic-EK-学习笔记"><a href="#网络流及-Dinic-EK-学习笔记" class="headerlink" title="网络流及 Dinic,EK 学习笔记"></a>网络流及 Dinic,EK 学习笔记</h1><p>网络流是 OI 中一种非常招人痛恨的算法，因其较难理解且<del>理解后也做不对题</del>。</p>
<p>网络流的基础知识听起来很抽象，但实际上并不是非常难理解。它分为 网络 和 流。（不然为啥子叫网络流？）</p>
<span id="more"></span>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>网络就是一张满足一些性质的图。</p>
<ul>
<li>首先，它是一张有向图。</li>
<li>图中的每条边都有一个 $c$ 值，代表这条边的容量。<br>可表示为 $c(u,v)_{(u,v\in V)}$</li>
<li>它具有两个特殊的点，源点和汇点。<br>（这两个点一般都不是题目给出的。）</li>
</ul>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是一个函数。流函数可表示为： $f(u,v)_{(u,v\in V)}$ 具体的性质分为以下三条，（这些性质名字看起来很高深，但类比水流很容易理解）</p>
<ol>
<li>容量限制：$f(u,v)\le c(u,v)$</li>
<li>斜对称性：$f(u,v) = - f(v,u)$</li>
<li>流守恒性：<script type="math/tex; mode=display">\forall x\in V,\text且 x \notin\{s,t\},\sum_{(u,x)\in E} f(u,x) = \sum_{(x,v)\in E} f(x,v)</script>(通俗理解一下，就是每个点都不会有“积水”)</li>
</ol>
<h2 id="用网络流能解决的问题"><a href="#用网络流能解决的问题" class="headerlink" title="用网络流能解决的问题"></a>用网络流能解决的问题</h2><p>网络流常见的问题可以概括理解为以下三种：</p>
<p>最大流问题：求一张网络从源点到汇点的最大流量。（这个问题也可以转变为二分图最大匹配问题。）</p>
<p>最小割问题：删掉总流量为 $X$ 的边使整张图不连通，最小的 $X$ 。仔细推一下就能发现，对于一张图，最小割和最大流其实得到的答案其实是一样的。</p>
<p>费用流问题：全称为最大费用最大流或者最小费用最大流。顾名思义，就是在网络中的每条边中加入一种属性，也就是这条边的费用。你在这条边上的花费就是 $\text{这条边的费用} \times \text{这条边的流量}$ 。要求优先满足最大流量的同时满足最大费用。</p>
<h2 id="解决网络流问题的算法"><a href="#解决网络流问题的算法" class="headerlink" title="解决网络流问题的算法"></a>解决网络流问题的算法</h2><h3 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="$Dinic$ 算法"></a>$Dinic$ 算法</h3><p>时间复杂度：$O(n^2m)$ （在二分图上是 $O(\sqrt nm)$ ）</p>
<p>虽然说这个复杂度看起来非常劣，但网络流算法的复杂度往往比这个上界低很多。我们只需要记住这个算法可以处理的数据范围是 $10^4 \sim 10^5$ 即可。</p>
<p>具体实现：</p>
<ul>
<li>每次先 $BFS$ 将这个残量网络（即每条边的容量减掉流量）构建为分层图。</li>
<li>后用 $DFS$ 在这个分层图上同时找出多条增广路。</li>
<li><p>将增广路上的边流量减小最大可减小剩余容量，同时将对应的反向边的剩余容量增加（方便后面“反悔”），这就要求我们建边时成对建边（听起来挺简单的？）</p>
<p>代码实现：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络流及 Dinic,EK 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"><span class="comment">//广度优先搜索构建分层图，d 数组为层次，e[x].t 是剩余容量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(s), d[s] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (d[y] || !e[i].t) <span class="keyword">continue</span>;  <span class="comment">//已经没有容量，即满流的边不需要考虑</span></span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      <span class="keyword">if</span> (y == t) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//构建到汇点 t 就可以停止了。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果没有增广路证明流量已达最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span> </span>&#123;  <span class="comment">//x 为当前节点，flow 是这个残量网络上可更新的最大流量</span></span><br><span class="line">  <span class="keyword">if</span> (x == t) <span class="keyword">return</span> flow;</span><br><span class="line">  ll rest = flow, k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i &amp;&amp; rest; i = e[i].nxt) &#123;  <span class="comment">//如果最大可更新流量已经是 0 了，那就没有什么搜下去的必要了。</span></span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!e[i].t || d[y] != d[x] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    k = <span class="built_in">dfs</span>(y, <span class="built_in">min</span>(e[i].t, rest));  <span class="comment">//由于经过了当前边，所以最大可更新流量最大时这条边的剩余容量。</span></span><br><span class="line">    <span class="keyword">if</span> (!k) d[y] = <span class="number">0</span>;</span><br><span class="line">    e[i].t -= k;</span><br><span class="line">    e[i ^ <span class="number">1</span>].t += k;</span><br><span class="line">    rest -= k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll flow;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (flow = <span class="built_in">dfs</span>(s, inf)) maxflow += flow;  <span class="comment">//flow 说过了，是残量网络上的最大流量，maxflow 是整张图的最大流量。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（好像确实不难？）</p>
<p><a href="https://www.luogu.com.cn/problem/P3376">P3376 [模板]网络最大流</a></p>
<p> 代码实现： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络流及 Dinic,EK 学习笔记</span></span><br><span class="line"><span class="comment">//dfs 向下递归时参数是 min(rest,e[i].t) 不要写成 flow</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> ll inf = (<span class="number">1ll</span> &lt;&lt; <span class="number">62</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">210</span>, Maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">  ll t;</span><br><span class="line">&#125; e[Maxm];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt = <span class="number">1</span>, d[Maxn];</span><br><span class="line">ll maxflow;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll t)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], t&#125;, hd[u] = cnt;</span><br><span class="line">  e[++cnt] = (edge)&#123;u, hd[v], <span class="number">0</span>&#125;, hd[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  <span class="keyword">while</span> (q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(s), d[s] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (d[y] || !e[i].t) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">      <span class="keyword">if</span> (y == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, ll flow)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == t) <span class="keyword">return</span> flow;</span><br><span class="line">  ll rest = flow, k;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i &amp;&amp; rest; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!e[i].t || d[y] != d[x] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    k = <span class="built_in">dfs</span>(y, <span class="built_in">min</span>(e[i].t, rest));</span><br><span class="line">    <span class="keyword">if</span> (!k) d[y] = <span class="number">0</span>;</span><br><span class="line">    e[i].t -= k;</span><br><span class="line">    e[i ^ <span class="number">1</span>].t += k;</span><br><span class="line">    rest -= k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flow - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ll flow;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">    <span class="keyword">while</span> (flow = <span class="built_in">dfs</span>(s, inf)) maxflow += flow;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, t; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">    <span class="built_in">add</span>(x, y, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="费用流-EK-算法"><a href="#费用流-EK-算法" class="headerlink" title="费用流 $EK$ 算法"></a>费用流 $EK$ 算法</h3><p>时间复杂度：$O(nmflow)$（flow 为边权和）</p>
<p>可处理的范围一般为 $10^3$</p>
<p>具体实现：</p>
<p>$EK$ 就是直接用广搜直接找增广路的算法。费用流 $EK$ 直接把广搜改为 $SPAF$ 即可。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络流及 Dinic,EK 学习笔记</span></span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPAF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(s), dis[s] = <span class="number">0</span>;</span><br><span class="line">  incf[s] = inf, incf[t] = <span class="number">0</span>;  <span class="comment">//残量网络的最大流量</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v, w = e[i].w, c = e[i].c;</span><br><span class="line">      <span class="keyword">if</span> (!w || dis[y] &lt;= dis[x] + c) <span class="keyword">continue</span>;</span><br><span class="line">      dis[y] = dis[x] + c, incf[y] = <span class="built_in">min</span>(w, incf[x]);</span><br><span class="line">      pre[y] = i;</span><br><span class="line">      <span class="keyword">if</span> (!vis[y]) q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>;  <span class="comment">//pre 数组记录最小路径</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incf[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改残量网络，统计最小花费和最大流量</span></span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  maxflow += incf[t];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = t; x != s; x = e[pre[x] ^ <span class="number">1</span>].v) &#123;</span><br><span class="line">    e[pre[x]].w -= incf[t], e[pre[x] ^ <span class="number">1</span>].w += incf[t];</span><br><span class="line">    mincost += incf[t] * e[pre[x]].c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3381">P3381 [模板]最小费用最大流</a><br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络流及 Dinic,EK 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf (1 &lt;&lt; 31 - 1)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e3</span> + <span class="number">10</span>, Maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt, w, c;</span><br><span class="line">&#125; e[Maxm];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], w, c&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">  e[++cnt] = (edge)&#123;u, hd[v], <span class="number">0</span>, -c&#125;;</span><br><span class="line">  hd[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[Maxn], pre[Maxn], incf[Maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[Maxn];</span><br><span class="line"><span class="keyword">int</span> s, t;</span><br><span class="line"></span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPAF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">  q.<span class="built_in">push</span>(s), dis[s] = <span class="number">0</span>;</span><br><span class="line">  incf[s] = inf, incf[t] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v, w = e[i].w, c = e[i].c;</span><br><span class="line">      <span class="keyword">if</span> (!w || dis[y] &lt;= dis[x] + c) <span class="keyword">continue</span>;</span><br><span class="line">      dis[y] = dis[x] + c, incf[y] = <span class="built_in">min</span>(w, incf[x]);</span><br><span class="line">      pre[y] = i;</span><br><span class="line">      <span class="keyword">if</span> (!vis[y]) q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> incf[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxflow, mincost;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  maxflow += incf[t];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = t; x != s; x = e[pre[x] ^ <span class="number">1</span>].v) &#123;</span><br><span class="line">    e[pre[x]].w -= incf[t], e[pre[x] ^ <span class="number">1</span>].w += incf[t];</span><br><span class="line">    mincost += incf[t] * e[pre[x]].c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, w, c; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;w, &amp;c);</span><br><span class="line">    <span class="built_in">add</span>(x, y, w, c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">SPAF</span>()) <span class="built_in">update</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, maxflow, mincost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论初步基础知识 学习笔记</title>
    <url>/Home/Game-Theory/</url>
    <content><![CDATA[<h1 id="博弈论初步基础知识-学习笔记"><a href="#博弈论初步基础知识-学习笔记" class="headerlink" title="博弈论初步基础知识 学习笔记"></a>博弈论初步基础知识 学习笔记</h1><p>关于博弈论这个算法，可能是算法竞赛中最实际的算法吧。博弈论算法虽然定理较多，但体系还算较完整。博弈论的学习很简单，代码量也相对较小，就是看能不能想出来正确的构造法。</p>
<span id="more"></span>
<h2 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h2><p>公平组合游戏，就像字面意思。既是回合制游戏，还得是公平的。说高大上一点，就是拥有状态集，终止状态集，状态转移边，可以在有限步数内结束的游戏。</p>
<p>是不是感觉这个规则要求太苛刻了？有什么创造性吗？所以这个规则并不完全是博弈论要讨论的内容。</p>
<h2 id="策梅洛定理"><a href="#策梅洛定理" class="headerlink" title="策梅洛定理"></a>策梅洛定理</h2><p>其表示在二人的有限游戏中，如果双方皆拥有完全的资讯，并且运气因素并不牵涉在游戏中，那先行或后行者当一必有一方有必胜/必不败的策略。  —百度百科</p>
<p>这种游戏相对于公平组合游戏规则就活泛多了。比如常玩的五子棋，围棋就不是公平组合游戏，因为甲放的棋子乙不能动。但他们都在策梅洛定理的研究范内。</p>
<p>博弈论的体系都是在这种游戏的基础上构建的。</p>
<p>设先手必胜状态为 $N$ 状态，先手必败状态为 $P$ 状态。</p>
<p>那么一个满足上述要求的游戏中，</p>
<p>如果一个状态 <strong>能</strong> 转移到 $P$ 状态，那么它一定是 $N$ 状态。</p>
<p>如果一个状态<strong>只能</strong>转移到 $N$ 状态，那么它一定是 $P$ 状态。<br>（上面一定要记准确了，不然 SG 函数会很难受）<br>所以对于任意状态集，都可以确定哪一方赢。</p>
<p>需要用数学归纳思想感性证明。</p>
<h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><p>有 n 个石子，两人轮流取，每次只能取 $[1,m]$ 个。最后取光者胜。</p>
<p>一个简单的构造就是 $(m+1)|n$ 时，先手必败，否则先手必胜。</p>
<p>这个应该挺好理解的。就是如果甲取 $k$ 个，则乙取 $m-k+1$ 个，这样始终可以保证不论甲取何值，乙都可以取且可以保证和一定。如果不能整除，那乙没有任何办法。</p>
<h2 id="Nim-游戏"><a href="#Nim-游戏" class="headerlink" title="Nim 游戏"></a>Nim 游戏</h2><p>有 𝑛 堆石子，每堆有 $a_i$ 个。每次从一堆中取任意个，取完最后一个石子者赢。</p>
<p>如果 $⊕ 𝑎_𝑖 = 0$ ，那么先手必败，否则先手必胜。</p>
<p>是不是突然感觉就蒙了？这个是咋构造出来的？不管你是不是，我是。</p>
<h2 id="sg-函数"><a href="#sg-函数" class="headerlink" title="sg 函数"></a>sg 函数</h2><p>先定义一个 $ygsg$ 函数：<br>$ygsg(x) = 1 (x\in N)$（这里的 N 是必胜态而不是数集 N ）<br>在根据上面的策梅洛定理，</p>
<script type="math/tex; mode=display">ygsg(x) = \begin{cases}0 &\nexists x->y,ygsg(y)=0\\1 &\exists x->y,ygsg(y)=0\end{cases}</script><p>然后再定义 $sg(x) = mex\{sg(y)|x-&gt;y\}$ 这个函数又是什么意思呢？</p>
<p>通俗理解一下，就是 sg 函数和他的状态转移边构成了一个 DAG，如果 sg(x) 这个状态可达的所有状态中，含有 P 状态，那么 $sg(x) &gt; 0$ 否则 $sg(x) = 0$，然后就得出了 $sg(x)&gt;0\leftrightarrow ygsg(x)=1\leftrightarrow x\in N$。然后就有 $sg(x,y) = sg(x) \oplus sg(y)$（具体为什么还是不太清楚）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>求解高次同余方程（离散对数） 学习笔记</title>
    <url>/Home/HOCE/</url>
    <content><![CDATA[<h1 id="求解高次同余方程（离散对数）-学习笔记"><a href="#求解高次同余方程（离散对数）-学习笔记" class="headerlink" title="求解高次同余方程（离散对数） 学习笔记"></a>求解高次同余方程（离散对数） 学习笔记</h1><p>时间复杂度：$O( \sqrt n log n )$ （不使用 $map$ 会剪掉一个 $log$）</p>
<p>高次同余方程不同于线性同余方程。例：</p>
<p>给定 $a, b, p$，（a,p 互质）求解 $x$ 使得 $a ^ x \equiv b (\mod p)$</p>
<p>可以通过 BSGS 算法$(Baby Step, Giant Step)$，来实现。</p>
<span id="more"></span>
<p>具体实现：</p>
<p>设 $x = i \times t - j$ ，其中 $t = \left\lceil \sqrt n \right\rceil$ ，$0 \le j \le t$ ，然后将方程移项，变成 $a ^ {i \times t} \equiv b \times a ^ j (\mod p)$ 。</p>
<p>然后枚举 $j \in [ 0, t - 1]$ ，将 $b \times a ^ j (\mod p)$ 插入 hash 表， 然后枚举 $i \in [0, t]$ ，求出 $a ^ {i ,t} (\mod p)$ 并在 hash 表中查找，如果找到就返回 $i \times t - j$， 否则说明没有答案。</p>
<p>证明：</p>
<p>$\because gcd(a,p) = 1$  </p>
<p>根据欧拉定理，$a ^ {\varphi (p)} \equiv 1 (\mod p)$</p>
<p>所以如果存在答案，一定在 $[1,p]$ 范围内，否则无解。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解高次同余方程（离散对数） 学习笔记</span></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">  map&lt; ll, ll &gt; hash;</span><br><span class="line">  hash.<span class="built_in">clear</span>();</span><br><span class="line">  ll t = ( ll ) <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">  b %= p;</span><br><span class="line">  <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; t; ++j) &#123;</span><br><span class="line">    ll val = b * <span class="built_in">Pow</span>(a, j, p) % p;  <span class="comment">//枚举 j ，将右半边插入 hash 表</span></span><br><span class="line">    hash[val] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  a = <span class="built_in">Pow</span>(a, t, p);                    <span class="comment">//以下所有 a 均为 a ^ t</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;  <span class="comment">//特判为 0 情况</span></span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    ll val = <span class="built_in">Pow</span>(a, i, p);</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(val) == hash.<span class="built_in">end</span>())  <span class="comment">//查表</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (i * t - hash[val] &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i * t - hash[val];  <span class="comment">//找答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3846">P3846 [TJOI2007] 可爱的质数/[模板]BSGS</a><br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求解高次同余方程（离散对数） 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Pow</span><span class="params">(ll x, ll y, ll p)</span> </span>&#123;</span><br><span class="line">  ll ans = <span class="number">1</span>;</span><br><span class="line">  x %= p;</span><br><span class="line">  <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % p;</span><br><span class="line">    x = x * x % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">BSGS</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">  map&lt; ll, ll &gt; hash;</span><br><span class="line">  hash.<span class="built_in">clear</span>();</span><br><span class="line">  b %= p;</span><br><span class="line">  ll t = ( ll ) <span class="built_in">sqrt</span>(p) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll j = <span class="number">0</span>; j &lt; t; ++j) &#123;</span><br><span class="line">    ll val = b * <span class="built_in">Pow</span>(a, j, p) % p;</span><br><span class="line">    hash[val] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  a = <span class="built_in">Pow</span>(a, t, p);</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    ll val = <span class="built_in">Pow</span>(a, i, p);</span><br><span class="line">    <span class="keyword">if</span> (hash.<span class="built_in">find</span>(val) == hash.<span class="built_in">end</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i * t - hash[val] &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i * t - hash[val];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  ll p, b, n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;p, &amp;b, &amp;n);</span><br><span class="line">  ll l = <span class="built_in">BSGS</span>(b, n, p);</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no solution&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, (l % p + p) % p);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树算法 (MST) 学习笔记</title>
    <url>/Home/MST/</url>
    <content><![CDATA[<h1 id="最小生成树算法-MST-学习笔记"><a href="#最小生成树算法-MST-学习笔记" class="headerlink" title="最小生成树算法 $(MST)$ 学习笔记"></a>最小生成树算法 $(MST)$ 学习笔记</h1><p>最小生成树算法是利用一张连通图中生成树和最小生成树的一些特性来解决问题的一种算法。常见的最小生成树算法包含 $Prim$ 和 $Kruskal$ 两种。</p>
<span id="more"></span>
<h2 id="prim"><a href="#prim" class="headerlink" title="$prim$"></a>$prim$</h2><p>时间复杂度 $O(mlogn)$</p>
<p>$prim$ 算法的实现与 $dijkstra$ 类似，但略有不同，本质上也是贪心优化的广度优先搜索算法。</p>
<p>具体实现：</p>
<ol>
<li>对于指定源点的，不做特殊处理；对于未指定节点的，建立一个超级源点，并向每个点连边。</li>
<li>初始化 $dis$ 数组为极大，并将源点放入优先队列，标记访问。</li>
<li>取出队头，遍历每一条非树边将元素放入队列，并更新 $dis$ ，更新答案，根据需求存边建树。</li>
</ol>
<p>ps:$dis$ 数组存储的是距离树上当前子节点的距离，并非距离源点的距离。</p>
<p>完整的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树算法 $(MST)$ 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1e5</span> + <span class="number">10</span>], vis[<span class="number">1e5</span> + <span class="number">10</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, t;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t &gt; y.t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt; node &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>((node)&#123;s, <span class="number">0</span>&#125;);  <span class="comment">//初始化操作</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; cnt &lt; n) &#123;</span><br><span class="line">    node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> x = tmp.u;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    cnt++;  <span class="comment">//记录已加入边数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (!vis[y] &amp;&amp; e[i].t &lt; dis[y]) &#123;  <span class="comment">//访问非树边</span></span><br><span class="line">        dis[y] = e[i].t;</span><br><span class="line">        q.<span class="built_in">push</span>((node)&#123;y, dis[y]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="$Kruskal$"></a>$Kruskal$</h2><p>时间复杂度 $O(mlogm)$</p>
<p>$kruscal$ 算法与 $Prim$ 本质不同，$kruscal$ 算法运用了贪心思想和并查集优化。</p>
<p>具体实现：</p>
<ol>
<li>用 $u,v,w$ 结构体存储临时边。</li>
<li>按边权从小到大排序。</li>
<li>枚举每一条边 $e_{i}(i\in n)$ ，用并查集判断 $u_{i},v_{i}$ 是否属于同一集合。</li>
<li>如果不是，证明可以连边且不破坏树形结构，否则枚举下一条边。</li>
<li>直到边数达到 $n-1$。</li>
</ol>
<p>代码容易理解不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小生成树算法 (MST) 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruscal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + <span class="number">1</span> + m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = e[i].u, y = e[i].v, t = e[i].t;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(u) != <span class="built_in">find</span>(v)) &#123;</span><br><span class="line">      f[<span class="built_in">find</span>(u)] = <span class="built_in">find</span>(v);</span><br><span class="line">      ans += w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems:"></a>Problems:</h1><ul>
<li><a href="https://cloudyskyet.github.io/Blog/p1967/">P1967 [NOIP2013 提高组] 货车运输</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/p2330/">P2330 [SCOI2005]繁忙的都市</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/p2502/">P2502 [HAOI2006]旅行</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/p2798/">P2798 爆弹虐场 </a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵 学习笔记</title>
    <url>/Home/Matrix/</url>
    <content><![CDATA[<h1 id="矩阵-学习笔记"><a href="#矩阵-学习笔记" class="headerlink" title="矩阵 学习笔记"></a>矩阵 学习笔记</h1><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>在数学中，矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，最早来自于方程组的系数及常数所构成的方阵。这一概念由19世纪英国数学家凯利首先提出。—百度百科</p>
<span id="more"></span>
<p>在 OI 中，矩阵也有很大的作用。一般写法为用结构题封装，靠重载运算符来定义运算。</p>
<p>矩阵运算法则：</p>
<ul>
<li>加法，减法：求 $a, b$ 矩阵的和：$res$ 的每一个点等于 $a$ 矩阵对应位置的点加上 $b$ 矩阵的对应位置的点。</li>
</ul>
<p>$res_{i,j}(0&lt;i,j&lt;sz) = a_{i,j} + b_{i,j}$</p>
<ul>
<li>矩阵乘法：要求左矩阵的行数等于右矩阵的列数 $res$ 的每个点等于 $a$ 矩阵对应行的所有点分别乘 $b$ 矩阵对应列的每个对应点 的和。</li>
</ul>
<p>$res_{i,j} = \sum_{k = 0}^{k &lt; sz} a_{i,k} \times b_{k,j}$</p>
<ul>
<li><p>由上可见，矩阵乘法满足结合律，但不满足交换律。</p>
</li>
<li><p>矩阵除法：需要用高斯消元求逆矩阵。</p>
</li>
</ul>
<p>还有一个需要注意的点：只有主对角线（左上到右下）为 1， 其他全为 0 的矩阵为单位矩阵，一般记作 $I$，任何矩阵乘单位矩阵都得它本身，在快速幂时会用到。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵 学习笔记</span></span><br><span class="line"><span class="keyword">namespace</span> Matrix &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> a[sz][sz];</span><br><span class="line">  <span class="built_in">mat</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>+(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        res.a[i][j] = (a[i][j] + T.a[i][j]) % p;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = a[i][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">          (res.a[i][j] += T.a[k][j] * r) %= P;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res, bas;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        bas.a[i][j] = a[i][j] % P;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> y = x;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * bas;</span><br><span class="line">      bas = bas * bas;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Matrix</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Matrix;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵加速递推"><a href="#矩阵加速递推" class="headerlink" title="矩阵加速递推"></a>矩阵加速递推</h2><p>时间复杂度：$O(sz^3 \times log n)$</p>
<p>矩阵加速递推是矩阵在 OI 中一种比较常用的用法，主要用于解决的是一个递推式要求的项数太多而 TLE 的问题。大多数矩阵加速递推都是从斐波那契数列入手：</p>
<p>$f_i = f_{i-1} + f_{i-2}(i \ge 3)$</p>
<p>这个式子都会写，但如果让求 $n = 1e18$ 时，就迷茫了。</p>
<p>这个时候就要用上矩阵了。</p>
<p>我们把转移要用的所有东西都放在矩阵里，对于斐波那契来说，这个矩阵就是 $[f_{i-1},f_{i-2}]$ ， 然后把他想要变成的样子也放在矩阵里，就是 $[f_i,f_{i-1}]$ 。（因为要继续递推，所以第二个矩阵的形式一定要和第一个矩阵保持一致）</p>
<p>接下来就要思考如何让第一个矩阵通过矩阵运算转移到第二个矩阵。我们就要从递推式 $f_i = f_{i-1} + f_{i-2}(i \ge 3)$ 入手。我们发现第二个矩阵的第一项要通过第一个矩阵的两项之和来转移，所以转移矩阵的第一列即为：1,1。然后第二个矩阵的第二项直接由第一个矩阵的第一项漂移过来，与第一个矩阵的第二项无关，所以转移矩阵的第二列即为：1,0。</p>
<p>所以完整的递推式：</p>
<p>$\begin{bmatrix}f_i&amp;f_{i-1}\end{bmatrix} = \begin{bmatrix}f_{i-1}&amp;f_{i-2}\end{bmatrix} \times \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$</p>
<p>因为要求第 n 项，即 $[1,1] \times \text{转移矩阵} \times \text{转移矩阵} \times \text{转移矩阵} \times …$，即 $[1,1] \times \text{转移矩阵}^{n-2}$（因为前两项已经在那了），这个时候就可以矩阵快速幂了，矩阵快速幂与普通快速幂类似。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Matrix &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">2</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> a[sz][sz];</span><br><span class="line">  <span class="built_in">mat</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = a[i][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">          (res.a[i][j] += T.a[k][j] * r) %= P;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res, bas;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        bas.a[i][j] = a[i][j] % P;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> y = x;</span><br><span class="line">    <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y &amp; <span class="number">1</span>) res = res * bas;</span><br><span class="line">      bas = bas * bas;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Matrix</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Matrix;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mat st;</span><br><span class="line">  st.a[<span class="number">0</span>][<span class="number">0</span>] = st.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  mat bs;</span><br><span class="line">  bs.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  bs.a[<span class="number">0</span>][<span class="number">0</span>] = bs.a[<span class="number">0</span>][<span class="number">1</span>] = bs.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  st = st * (bs ^ (n - <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, st.a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="updated-2021-10-02"><a href="#updated-2021-10-02" class="headerlink" title="updated: 2021-10-02"></a>updated: 2021-10-02</h1><h2 id="线段树套矩阵"><a href="#线段树套矩阵" class="headerlink" title="线段树套矩阵"></a>线段树套矩阵</h2><p>时间复杂度：$O(nlogn\times sz^3)$</p>
<p>既然矩阵拥有自己独立且较完整的运算法则，满足区间可加性，那么它就也可以用线段树维护。</p>
<p>线段树套矩阵支持区间乘 $bs$ 幂，区间求和。大部分操作和普通线段树是一样的，值得注意的是，$tag$ 标记必须打成矩阵，而非整形，否则会导致每次下传标记都要矩阵快速幂，从而时间复杂度退化。</p>
<p>具体实现：</p>
<p>建树时将每个节点的的 $tag$ 打成 $I$ 矩阵，每次下传标记时将 $tag$ 与 $I$ 比较，如果不同则代表标记被修改过，下传标记后仍将 $tag$ 打成 $I$。查询时返回值设为 $mat$ 即可。</p>
<p>其他与普通线段树一致。<br>代码实现：</p>
<p><a href="https://www.luogu.com.cn/problem/CF718C">CF718C Sasha and Array</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Matrix &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> a[sz][sz];</span><br><span class="line">  <span class="built_in">mat</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>+(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        res.a[i][j] = (a[i][j] + T.a[i][j]) % P;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>*(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sz; ++k) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = a[i][k] % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">          (res.a[i][j] += r * T.a[k][j] % P) %= P;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>^(<span class="keyword">long</span> <span class="keyword">long</span> x) &#123;</span><br><span class="line">    mat res, bs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) res.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        bs.a[i][j] = a[i][j] % P;</span><br><span class="line">    <span class="keyword">for</span> (; x; x &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &amp; <span class="number">1</span>) res = res * bs;</span><br><span class="line">      bs = bs * bs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        <span class="keyword">if</span> (a[i][j] != T.a[i][j]) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Matrix</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[Maxn];</span><br><span class="line"></span><br><span class="line">mat bs, I;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_Tree &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  mat dat, tag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].dat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> t(x) St[x].tag</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="built_in">t</span>(p) = I;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) = bs ^ (a[l] - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">  <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">t</span>(p) == I) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">v</span>(ls) = <span class="built_in">v</span>(ls) * <span class="built_in">t</span>(p);</span><br><span class="line">  <span class="built_in">v</span>(rs) = <span class="built_in">v</span>(rs) * <span class="built_in">t</span>(p);</span><br><span class="line">  <span class="built_in">t</span>(ls) = <span class="built_in">t</span>(ls) * <span class="built_in">t</span>(p);</span><br><span class="line">  <span class="built_in">t</span>(rs) = <span class="built_in">t</span>(rs) * <span class="built_in">t</span>(p);</span><br><span class="line">  <span class="built_in">t</span>(p) = I;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, mat k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) = <span class="built_in">v</span>(p) * k;</span><br><span class="line">    <span class="built_in">t</span>(p) = <span class="built_in">t</span>(p) * k;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">spread</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">add</span>(ls, l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">add</span>(rs, l, r, k);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mat <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">spread</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  mat ans;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    ans = ans + <span class="built_in">ask</span>(ls, l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    ans = ans + <span class="built_in">ask</span>(rs, l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Segment_Tree</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segment_Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  mat st;</span><br><span class="line">  st.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  bs.a[<span class="number">0</span>][<span class="number">0</span>] = bs.a[<span class="number">0</span>][<span class="number">1</span>] = bs.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  I.a[<span class="number">0</span>][<span class="number">0</span>] = I.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> opt, l, r;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">      mat tmp = bs ^ k;</span><br><span class="line">      <span class="built_in">add</span>(<span class="number">1</span>, l, r, tmp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mat ans = st;</span><br><span class="line">      ans = ans * <span class="built_in">ask</span>(<span class="number">1</span>, l, r);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans.a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="update-2021-12-7"><a href="#update-2021-12-7" class="headerlink" title="update:2021-12-7"></a>update:2021-12-7</h1><p>大概是 10.1 集训的时候学的这东西了，之前一直没来及写。</p>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>定义：</p>
<p>令 $\mu(P)$ 为 $P$ 排列的逆序对数。<br>则 </p>
<script type="math/tex; mode=display">del(A) = \sum_P(-1)^{\mu(P)} \prod_k A_{k, p_k}</script><p><del>这玩意有没有啥具象意义我是不知道，反正就这么算的。</del></p>
<p>这个东西还有一些性质，用来加快运算：</p>
<ol>
<li>$I$ 的行列式为 $1$</li>
<li>交换行列式的两行，行列式变号。</li>
<li>矩阵行列式具有线性性<ul>
<li>若某一行乘 t，则行列式乘 t。</li>
<li>两个矩阵若只有一行不同则两个矩阵的行列式之和为当前行依次相加的矩阵的行列式。即为：<script type="math/tex; mode=display">\begin{vmatrix}x + x' & y + y'\\ a & b\end{vmatrix} = \begin{vmatrix}x & y \\ a & b\end{vmatrix} + \begin{vmatrix}x' & y'\\ a & b\end{vmatrix}</script></li>
</ul>
</li>
<li>有某两行一样的矩阵，行列式是 0。</li>
<li>用矩阵的一行加上另一行的倍数，行列式不变。即为：<script type="math/tex; mode=display">\begin{vmatrix}\ x & y \\ a & b \end{vmatrix} = \begin{vmatrix} x & y \\ a + kx & b + ky \end{vmatrix}</script></li>
</ol>
<p>依次给出证明：</p>
<ol>
<li>比较简单，因为只有主对角线一种排列方案最终会产生贡献。</li>
<li>因为交换两行相当于每个排列相较于原来都有两个数发生了变化，根据逆序对的性质，逆序对会发生奇数个变化。则前面的 $(-1)^{\mu(P)}$ 相较于原来会取反，导致行列式取反。</li>
<li><ul>
<li>因为每行只选一个数，根据乘法分配律，成立。</li>
<li>同样因为每行只选一个数，根据乘法分配律，成立。</li>
</ul>
</li>
<li>因为交换任意两行行列式取反，又因为交换相同的两行，矩阵并没有发生本质上的变化，所以 0 的相反数为 0。</li>
<li>构造一个矩阵 $A = \begin{vmatrix} x &amp; y \\ x &amp; y \end{vmatrix}$, $B = \begin{vmatrix}\ x &amp; y \\ a &amp; b \end{vmatrix}$ 根据上述规则，$del(A) = 0$，$A’ = \begin{vmatrix} x &amp; y \\ kx &amp; ky \end{vmatrix}$ 则 $del(A’) = 0$。然后… $del(A’ + B) = del(A’) + del(B) = del(B)$ 。</li>
</ol>
<p><del>啊，我第一次学的时候没觉着有这么显然呀…</del></p>
<p>具体实现：<br>然后有了这几条性质，我们就可以用消元求行列式了。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵 学习笔记</span></span><br><span class="line"><span class="comment">// 大体思路是先找到当前列中非零的某个值所对应的行号（一般为最大值），然后交换到当前行，然后把没有固定的行当前列消为零，最后行列式的值即为主对角线各值之积。</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> mx = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Abs</span>(a[j][i]) &gt; <span class="built_in">Abs</span>(a[mx][i]))</span><br><span class="line">        mx = j;</span><br><span class="line">    <span class="keyword">if</span> (mx != i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="built_in">swap</span>(a[i][j], a[mx][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">      <span class="keyword">double</span> mul = a[k][i] / a[i][i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">        a[k][j] -= a[i][j] * mul;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Abs</span>(a[i][i]) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) res *= a[i][i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Abs</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><p>矩阵树这个东西是用来计数的，他能实现的功能就是求一张图的生成树个数。大概包括无向图，有向图外向树，有向图内向树。但不能包括自环。</p>
<p>首先要了解 3 种关于图的矩阵：</p>
<ol>
<li>邻接矩阵，记为 $A$ ，这个应该没有什么问题。</li>
<li>度数矩阵，记为 $D$ ，这个矩阵只有主对角线上有值，$D_{i, i}$ 即为 i 节点的度数。</li>
<li>基尔霍夫矩阵（最烦音译了，就叫他矩阵树矩阵吧），记为 $K$， $K = D - A $。</li>
</ol>
<p>设 $K’$ 为 $K$ 去掉第 $k$ 行，第 $k$ 列 $k \in (1, n)$ 后的矩阵。（一般删根）</p>
<p>最终的答案就是 $del(K’)$</p>
<p>证明不会。。。</p>
<p><a href="https://www.luogu.com.cn/problem/P4336">P4336 [SHOI2016]黑暗前的幻想乡</a>:</p>
<p>代码实现（这道题还用了容斥）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩阵 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Abs</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">  x %= P;</span><br><span class="line">  <span class="keyword">for</span> (; y; y &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = (ans * x) % P;</span><br><span class="line">    x = (x * x) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans % P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Matrix &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mat</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> a[sz][sz];</span><br><span class="line">  <span class="built_in">mat</span>() &#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>+(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        res.a[i][j] = (a[i][j] + T.a[i][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  mat <span class="keyword">operator</span>-(<span class="keyword">const</span> mat&amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">    mat res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; ++j)</span><br><span class="line">        res.a[i][j] = (a[i][j] + P - T.a[i][j]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> mx = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Abs</span>(a[j][i]) &gt; <span class="built_in">Abs</span>(a[mx][i]))</span><br><span class="line">          mx = j;</span><br><span class="line">      <span class="keyword">if</span> (mx != i) &#123;</span><br><span class="line">        res *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">          <span class="built_in">swap</span>(a[i][j], a[mx][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> div = a[k][i] * <span class="built_in">Pow</span>(a[i][i], P - <span class="number">2</span>) % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">          a[k][j] = ((a[k][j] - a[i][j] * div % P) % P + P) % P;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Abs</span>(a[i][i]) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res = (res + P) % P;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) (res *= a[i][i]) %= P;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Abs</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Matrix</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> siz[<span class="number">262144</span>], u[<span class="number">20</span>][<span class="number">400</span>], v[<span class="number">20</span>][<span class="number">400</span>], m[<span class="number">20</span>];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> up = (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m[i]; j++) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u[i][j], &amp;v[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= up; i++) &#123;</span><br><span class="line">    siz[i] = siz[i &gt;&gt; <span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= up; j++) &#123;</span><br><span class="line">    mat K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, p = j; p; p &gt;&gt;= <span class="number">1</span>, i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((p &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m[i]; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> U = u[i][k] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> V = v[i][k] - <span class="number">1</span>;</span><br><span class="line">        K.a[U][U]++;</span><br><span class="line">        K.a[V][V]++;</span><br><span class="line">        K.a[U][V] = (K.a[U][V] + P - <span class="number">1</span>) % P;</span><br><span class="line">        K.a[V][U] = (K.a[V][U] + P - <span class="number">1</span>) % P;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> det = K.<span class="built_in">calc</span>(n - <span class="number">1</span>);</span><br><span class="line">    ans = (ans + P + ((n - siz[j]) % <span class="number">2</span> ? det : -det)) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2021 游记及题解</title>
    <url>/Home/NOIP2021/</url>
    <content><![CDATA[<h1 id="NOIP2021-游记及题解"><a href="#NOIP2021-游记及题解" class="headerlink" title="NOIP2021 游记及题解"></a>NOIP2021 游记及题解</h1><h2 id="浅述我的-NOIP2021-学习（划水）经历"><a href="#浅述我的-NOIP2021-学习（划水）经历" class="headerlink" title="浅述我的 NOIP2021 学习（划水）经历"></a>浅述我的 NOIP2021 学习（划水）经历</h2><span id="more"></span>
<p>$day -9:$</p>
<p>开始了停文化课的生活。</p>
<p>$day -6$</p>
<p>一天冲了 10 道题，大部分是弱项 DP，非常地开心。</p>
<p>$day -2:$</p>
<p>打了场全真模拟，靠瞎暴力和瞎骗分水了个 Rank 5, 没个卵用。。。</p>
<p>$day -1:$</p>
<p>上午回顾了一下自暑假以来被吊打的生活。</p>
<p>下午和学弟一起敲板子，被学弟吊打了/kk，做了一下去年 CSP 题（你问为什么不是 NOIP？我太弱了）瞄了一眼贪吃蛇题解发现我去年好像推出来结论了很开心。</p>
<p>头熄灯前照着本部的照片拍了个低仿版… 感谢 $\text{凉笙}$ 大神帮忙拍照</p>
<p><img src="/Blog/imgs/post_imgs/NOIP2021rp++.jpg" alt=""></p>
<p>晚上睡不着和 $\text{宝硕}$，$youwike$，$zzf$ 在机房聊天，聊着聊着发现原来人家在叙旧，我在…</p>
<p>$day 0:$</p>
<p>在公交车上拿着昨天没写完的贪吃蛇，用 kupi 学长的热点交了一发 20 分，确认没挂，再瞄一眼题解：哦，只对了一半…（也不想想怎么可能切黑的）。</p>
<p>扭头一看，一车人都在睡觉。</p>
<p>上考场之前想再写一遍 FHQ 板子，结果没写出来。。。</p>
<p>马上进考场发现笔还在书包里，赶紧跑回去拿 $rp—$ 。</p>
<p>上考场，发现坐在离老师最远的一排，不错，风水宝地。<br>刚开题，四道都还没瞅完，机房里键盘声已经“振聋发聩”了。看到 T4 一页多的题面，我… </p>
<p>开始写 T1。想到了筛法，也不知道可不可过，莽他就完事了。测了一下大样例，挂了。哦 $1e7 + 1$。改了之后又在 Linux 测了一下。没变？？ Windows 一跑，对了。噫~好，玄学。把 Linux 终端重开一下，重复上面操作，哪里不对劲，刚刚忘编译了。。。</p>
<p>来来回回折腾了 1 小时，开 T2。一看 S 太大，必然爆 long long 。又涉及到了组合数（永远的痛）。果断爆搜。</p>
<p>T3 莫名奇妙拿到式子就想推，推一步，错一步，验算一步，改一步，来来回回<em>什么也没有得到</em>。赶紧打了个最小得分暴力爬了。</p>
<p>距离考试结束还剩 30 分钟，看了眼 T4，哦，可做，亏大了！！赶紧补救，最后 CE 遗憾删代码。</p>
<p>出考场，怎么都在随机化啊啊喂，这还是我认识的 OI 吗？</p>
<p>一测部分分拿稳了，民间数据最终得分：</p>
<script type="math/tex; mode=display">100 + 20 + 12 + 0 = 132</script><p>唯一的遗憾就是被 T4 题面吓到了，没有来及写暴力。补了一周多的 DP 连 T2 两维暴力都没想出来也挺可惜的。替挂分遗憾退役的学长感到惋惜，尤其是刘雅奇学长，人真的很好，还有 kupi 学长，拿到了迟来的一等。</p>
<p>下午回学校昏昏沉沉的，感冒又反复了。</p>
<p>$day:1$</p>
<p>水了一天，写了游记</p>
<p>后记：</p>
<p>分数和估的一样（毕竟是暴力），HE rank 60。</p>
<h1 id="update-2021-12-21"><a href="#update-2021-12-21" class="headerlink" title="update: 2021-12-21"></a>update: 2021-12-21</h1><p>补叙：貌似 T4 写了暴力也拿不到分…</p>
<h2 id="NOIP-T1-T3-题解"><a href="#NOIP-T1-T3-题解" class="headerlink" title="NOIP T1-T3 题解"></a>NOIP T1-T3 题解</h2><h2 id="P7960-NOIP2021-报数"><a href="#P7960-NOIP2021-报数" class="headerlink" title="P7960 [NOIP2021] 报数"></a><a href="https://www.luogu.com.cn/problem/P7960">P7960 [NOIP2021] 报数</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>多组询问，求出来在 $x \in [1, 1e7], f(x)$ 其中 $f(x)$ 表示 x 的下一个不是任意一个含 7 的数的整数倍的数，若 x 本身不满足，输出 <code>-1</code>。</p>
<h3 id="题目正解"><a href="#题目正解" class="headerlink" title="题目正解"></a>题目正解</h3><p>类素数筛法 + 指针/二分</p>
<h3 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h3><p>没有什么思维难度，写一个含 7 数判定函数和一个类素数筛，边筛边更新指针，最后一问一答 $O(1)$ 输出。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(nloglogn)$</p>
<h3 id="题目代码-多写了一个右指针，不过没什么影响"><a href="#题目代码-多写了一个右指针，不过没什么影响" class="headerlink" title="题目代码 (多写了一个右指针，不过没什么影响)"></a>题目代码 (多写了一个右指针，不过没什么影响)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn= <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="built_in">getchar</span> ();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>);</span><br><span class="line">        c = <span class="built_in">getchar</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">7</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x /= <span class="number">10</span>) <span class="keyword">if</span> (x % <span class="number">10</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l[Maxn], r[Maxn], lst;</span><br><span class="line"><span class="keyword">bool</span> vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (l, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (l));</span><br><span class="line">    <span class="built_in">memset</span> (r, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (r));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)<span class="number">1e7</span> + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">check</span> (i)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i * j &lt;= (<span class="keyword">int</span>)<span class="number">1e7</span> + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                vis[i * j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l[i] = lst, r[lst] = i;</span><br><span class="line">            lst = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span> ();</span><br><span class="line">    <span class="keyword">int</span> t = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span> ();</span><br><span class="line">        <span class="keyword">if</span> (l[x] == <span class="number">-1</span> &amp;&amp; r[x] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, r[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P7961-NOIP2021-数列"><a href="#P7961-NOIP2021-数列" class="headerlink" title="P7961 [NOIP2021] 数列"></a><a href="https://www.luogu.com.cn/problem/P7961">P7961 [NOIP2021] 数列</a></h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定整数 $n, m, k$，和一个长度为 $m + 1$ 的正整数数组 $v_0, v_1, \ldots, v_m$ 。<br>对于一个长度为 $n$，下标从 $1$ 开始且每个元素均不超过 $m$ 的非负整数序列 $\{a_i\}$ ，我们定义它的权值为 $v_{a_1} \times v_{a_2} \times \cdots \times v_{a_n}$ 。<br>当这样的序列 $\{a_i\}$ 满足整数 $S = 2^{a_1} + 2^{a_2} + \cdots + 2^{a_n}$ 的二进制表示中 $1$ 的个数不超过 $k$ 时，我们认为 $\{a_i\}$ 是一个合法序列。</p>
<p>计算所有合法序列 $\{a_i\}$ 的权值和对 $998244353$ 取模的结果。</p>
<h3 id="题目正解-1"><a href="#题目正解-1" class="headerlink" title="题目正解"></a>题目正解</h3><p>状压 DP + 可重集排列</p>
<h3 id="题目思路-1"><a href="#题目思路-1" class="headerlink" title="题目思路"></a>题目思路</h3><p>首先考场上是没有想到的，出考场之后听说 DP 能拿 50, wtc?</p>
<p>然后写了一下 50 分 DP, 大概可以把它算成背包？<br>$f_{i, s}$ 表示当前 dp 到第 i 位，已经选出来的总和为 s 的贡献（这里实际上是消掉了 j 维），枚举 i, j(现在在考虑 m 中的哪个元素), s ，最后根据 popcnt 计算合法，统计答案。</p>
<script type="math/tex; mode=display">f_{i, s} += f_{i - 1, s - 2^j} \times v_j</script><p>复杂度 $O(n^2m\times 2^m)$</p>
<p>然后考虑优化，首先可以想到用可重集排列来优化，因为样例解释中已经给到提示了。<br>因为很显然 S 的大小会爆 long long ，所以要考虑把 S 维拆掉，进行一些替换。<br>因为在 v 中依次选择的数下标是单调的增。所以已经计算过的位就不必计较具体数值。<br>且可以发现，一个数对当前 s 的影响最多比当前位高 5 位，<br>所以思路逐渐清晰，可以将 s 拆成 k 和 s’ 分别表示已经弃掉的位置一共包含几个 1 以及 s 当前和未来 5 位。<br>设 $f_{i, j, k, s’}$ 表示当前 dp 到选择了 i 个数，当前拓展到 v 数组第 j 位，向高位拓展 5 位为 k, 已经弃掉的位置共有 s’ 个 1 的贡献数。<br>嵌套枚举 i, j, k, s’, p(当前位置新选择的个数) 来更新 f 数组。<br>现在刷表已经不太合适了，所以改用填表。</p>
<p>于是乎转移方程为</p>
<script type="math/tex; mode=display">f_{i + p, j, k + ((s' \& 1) xor (p \& 1)), (s' / 2) + (p / 2) + ((s' \& 1) \&\& (p \& 1))} += f_{i, j - 1, k, s'} \times v^p_i / (p!)</script><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n^3m^2)$</p>
<h3 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> popcnt __builtin_popcountll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">110</span>, N = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp 数组， v 数组的次方</span></span><br><span class="line"><span class="keyword">int</span> f[N][M][N][M], v[M][N];</span><br><span class="line"><span class="comment">// 阶乘， 阶乘的逆， 线性求逆元数组</span></span><br><span class="line"><span class="keyword">int</span> fac[M], ifac[M], inv[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 预处理阶乘和阶乘的逆。</span></span><br><span class="line">  fac[<span class="number">1</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  ifac[<span class="number">1</span>] = ifac[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">    inv[i] = (P - P / i) * inv[P % i] % P;</span><br><span class="line">    ifac[i] = ifac[i - <span class="number">1</span>] * inv[i] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读入与预处理 v 的次方</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>() + <span class="number">1</span>, K = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    v[i][<span class="number">1</span>] = <span class="built_in">read</span>(), v[i][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; ++j)</span><br><span class="line">      v[i][j] = v[i][j - <span class="number">1</span>] * v[i][<span class="number">1</span>] % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// dp</span></span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= <span class="number">70</span>; ++s)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= n - i; ++p)</span><br><span class="line">            (f[i + p][j][k + ((s &amp; <span class="number">1</span>) ^ (p &amp; <span class="number">1</span>))][(s / <span class="number">2</span>) + (p / <span class="number">2</span>) + ((s &amp; <span class="number">1</span>) &amp;&amp; (p &amp; <span class="number">1</span>))] += f[i][j - <span class="number">1</span>][k][s] * v[j][p] % P * ifac[p] % P) %= P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 统计答案</span></span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= <span class="number">70</span>; ++s)</span><br><span class="line">      <span class="keyword">if</span> (k + <span class="built_in">popcnt</span>(s) &lt;= K)</span><br><span class="line">        ans = (ans + f[n][m][k][s] * fac[n] % P) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P7962-NOIP2021-方差"><a href="#P7962-NOIP2021-方差" class="headerlink" title="P7962 [NOIP2021] 方差"></a><a href="https://www.luogu.com.cn/problem/P7962">P7962 [NOIP2021] 方差</a></h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个序列 a, 每次可以选定 $x\in (1, n)$ ， 将 $a_x$ 改为 $a_{x - 1} + a_{x + 1} - a_x$ 。求经过任意次操作后的最小方差的 $n^2$ 倍。</p>
<h3 id="题目正解-2"><a href="#题目正解-2" class="headerlink" title="题目正解"></a>题目正解</h3><p>构造 + dp</p>
<h3 id="题目思路-2"><a href="#题目思路-2" class="headerlink" title="题目思路"></a>题目思路</h3><p>这道题能提供的思路就比较匮乏了。<br>首先，这道题和差分有关。怎们想到差分的不懂。发现每次操作相当于交换差分数组的两个位置。<br>发现最优情况下差分数组一定是单谷形的。<br>然后考虑先排序再 dp ，思路大概是一个反着的方格取数。<br>题中的差分可以化简为 $n\sum a_i^2 + (\sum a_i)^2$<br>$f_{i, j}$ 表示已经放了 i 个数，当前总和为 j 的平方和的最小值。<br>每次考虑将当前数放在左边还是右边即可。  </p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(na^2)$</p>
<h3 id="题目代码-1"><a href="#题目代码-1" class="headerlink" title="题目代码"></a>题目代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], x[Maxn], f[<span class="number">2</span>][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">read</span> ();</span><br><span class="line">  n--;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    x[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">  <span class="built_in">sort</span> (x + <span class="number">1</span>, x + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s += x[i] * i;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>, u = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s; ++ j)</span><br><span class="line">    f[u][j] = inf;</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    d = x[i], u ^= <span class="number">1</span>, cnt += d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, k; j &lt;= s; ++j) &#123;</span><br><span class="line">      f[u][j] = inf;</span><br><span class="line">      k = j - i * d;</span><br><span class="line">      <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">        f[u][j] = <span class="built_in">min</span> (f[u][j], f[u ^ <span class="number">1</span>][k] + i * d * d + <span class="number">2</span> * k * d);</span><br><span class="line">      k = j - cnt;</span><br><span class="line">      <span class="keyword">if</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">        f[u][j] = <span class="built_in">min</span> (f[u][j], f[u ^ <span class="number">1</span>][k] + cnt * cnt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= s; ++j)</span><br><span class="line">    <span class="keyword">if</span> (f[u][j] &lt; inf)</span><br><span class="line">      ans = <span class="built_in">min</span> (ans, (n + <span class="number">1</span>) * f[u][j] - j * j);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>数论初步 学习笔记</title>
    <url>/Home/Number-Theory/</url>
    <content><![CDATA[<p>这篇博客仍然很不完整，性质和性质的证明仍没有完全注明。</p>
<span id="more"></span>
<h1 id="数论初步-学习笔记"><a href="#数论初步-学习笔记" class="headerlink" title="数论初步 学习笔记"></a>数论初步 学习笔记</h1><h2 id="卷积与乘法卷积"><a href="#卷积与乘法卷积" class="headerlink" title="卷积与乘法卷积"></a>卷积与乘法卷积</h2><p>卷积通俗理解就是求三个函数关系的式子。常见的有加法卷积和乘法卷积，又称狄利克雷卷积。<br>加法卷积的公式为：</p>
<script type="math/tex; mode=display">g(n) = \sum_{i = 1}^n f(i) \times h(n - i)</script><p>但它不在这次的研究范围内。</p>
<p>乘法卷积的公式为：</p>
<script type="math/tex; mode=display">g(n) = \sum_{d|n} f(d) \times h(n/d)</script><p>为什么数论函数会和这个东西有关系呢？</p>
<p>因为它的求和条件 $d|n$ 会产生许多性质。</p>
<p>先来说明三个和卷积有关的函数。</p>
<ol>
<li>$\varepsilon$ 函数，又称元函数。定义式： $\varepsilon(1) = 1, \varepsilon(n) = 0 (n \ne 1)$</li>
<li>$I$ 函数，又称恒等函数。定义式： $I(n) = 1$</li>
<li>$Id$ 函数，又称单位函数。定义式： $Id(n) = n$</li>
</ol>
<p>这三个函数是乘法卷积的基本函数，接下来只需要用他们 <del>瞎搞</del> 进行一些推算。</p>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="简单性质"><a href="#简单性质" class="headerlink" title="简单性质"></a>简单性质</h3><ol>
<li>与乘法卷积的关系： $\varphi * I = Id$ </li>
</ol>
<p>即 $\sum_{d|n} \varphi(d) = n$</p>
<p>也就是欧拉反演。<br>因为这个性质，欧拉函数经常被用来求解有关 gcd 的问题。</p>
<p>证明需要用到等比数列求和公式和积性函数的性质。</p>
<ol>
<li>运用算术基本定理求 $\varphi$  <script type="math/tex; mode=display">n = p_1^{c_1}p_2^{c_2}\dots p_m^{c_m}</script></li>
</ol>
<script type="math/tex; mode=display">\varphi(n) = n \times (p_1-1)/p_1 \times (p_2-1)/p_2\times \dots \times (p_m-1)/p_m = n\times \prod_{\text{质数}p|n}(1-1/p)</script><p>证明需要用到容斥原理。且根据这个式子，可以推得 $\varphi$ 是一个积性函数，即当 $gcd(n,m) = 1$ 成立时，$\varphi(nm) = \varphi(n)\times\varphi(m)$</p>
<ol>
<li>如果 $p_1 | n$ 且 $p_1 ^ 2 | n$ ，则 $\varphi(n) = \varphi(n/p_1) \times p_1$ ；</li>
</ol>
<p>证明：<br>令 $n’ = n / p$, 由 $p ^ 2 | n$ 可知 $p | n’$。</p>
<p>根据定义式</p>
<script type="math/tex; mode=display">\varphi(n') = n' \times \prod_{\text{质数}p|n}(1-1/p)</script><script type="math/tex; mode=display">\because p_1 \in p</script><script type="math/tex; mode=display">\therefore \varphi(n'p_1) = n'\times \prod_{\text{质数}p|n}(1-1/p) \times p = \varphi(n') \times p_1</script><ol>
<li>如果 $p|n$ 且 $p^2\nmid n$ ，则 $\varphi(n) = \varphi(n/p) \times \varphi(p) = \varphi(n/p) \times (p - 1)$</li>
</ol>
<p>这个两个性质要在线性筛求 $\varphi$ 时用到。</p>
<p>证明：</p>
<p>令 $n’ = n / p$，由 $p^2\nmid n$ 可知 $gcd (p, n’) = 1$。</p>
<p>根据积性函数定义 $\varphi(n’p) = \varphi(n’) \times \varphi(p)$ 。</p>
<h3 id="线性筛求-varphi"><a href="#线性筛求-varphi" class="headerlink" title="线性筛求 $\varphi$"></a>线性筛求 $\varphi$</h3><p>时间复杂度：$O(n)$</p>
<p>这种算法主要应用于求一段比较连续的区间的 $\varphi$ 函数。需要用到性质 3, 4 。</p>
<p>具体实现：</p>
<p>利用欧拉筛在求素数的同时，枚举的 $p_j$ 相当于上文的 $p_1$, $i$ 为 $n’$, $i \times p_j$ 即为 $n$ 。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数论初步 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>; phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! book[i] ) &#123;</span><br><span class="line">      book[i] = i; p[++cnt] = i; </span><br><span class="line">      phi[i] = <span class="number">1ll</span> * ( i - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( p[j] &gt; book[i] || i * p[j] &gt; n ) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      book[i*p[j]] = p[j]; </span><br><span class="line">      phi[i*p[j]] = <span class="number">1ll</span> * phi[i] * p[j];</span><br><span class="line">      <span class="keyword">if</span> ( i % p[j] ) phi[i*p[j]] -= phi[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="因式分解求-varphi"><a href="#因式分解求-varphi" class="headerlink" title="因式分解求 $\varphi$"></a>因式分解求 $\varphi$</h3><p>时间复杂度：$O(logn)$</p>
<p>这种算法一般应用于用到 $\varphi$ 次数较少的时候。</p>
<p>具体实现：</p>
<p>也要利用算数基本定理，通过对 n 进行因式分解，很直接地求出 $\varphi$ 函数。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数论初步 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">  ll ans = n;</span><br><span class="line">  <span class="keyword">for</span> ( ll i = <span class="number">2</span>; i * i &lt;= n; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( n % i == <span class="number">0</span> )</span><br><span class="line">      ans = ans / i * ( i - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">while</span> ( n % i == <span class="number">0</span> ) n /= i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt; <span class="number">1</span> ) </span><br><span class="line">    ans = ans / n * ( n - <span class="number">1</span> );</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="varphi-函数求解有关-gcd-问题"><a href="#varphi-函数求解有关-gcd-问题" class="headerlink" title="$\varphi$ 函数求解有关 $gcd$ 问题"></a>$\varphi$ 函数求解有关 $gcd$ 问题</h3><p>一道经典例题就是 $\sum_{i=1}^n\sum_{i=1}^n gcd(i,j)$ 。</p>
<p>具体实现：<br>这时候我们就要用到 $\varphi$ 的性质，$\sum \varphi(d) = n$ ，将这个式子化简为：  </p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{i=1}^n \sum_{d|gcd(i,j)}\varphi(d)</script><p>然后可以改变 $\sum$ 的顺序，变成：</p>
<script type="math/tex; mode=display">
\sum_d\sum_{i=1}^{\left\lfloor n/d \right\rfloor}\sum_{i=1}^{\left\lfloor n/d\right\rfloor} \varphi(d)</script><p>然后就可以利用整数分块和前缀和解决这道题。  </p>
<p><a href="https://www.luogu.com.cn/problem/P2398">P2398 GCD SUM</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数论初步 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> p[Maxn], book[Maxn];</span><br><span class="line">ll phi[Maxn], sum[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>; phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ! book[i] ) &#123;</span><br><span class="line">      book[i] = i; p[++cnt] = i; </span><br><span class="line">      phi[i] = <span class="number">1ll</span> * ( i - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( p[j] &gt; book[i] || i * p[j] &gt; n ) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      book[i*p[j]] = p[j]; </span><br><span class="line">      phi[i*p[j]] = <span class="number">1ll</span> * phi[i] * p[j];</span><br><span class="line">      <span class="keyword">if</span> ( i % p[j] ) phi[i*p[j]] -= phi[i];</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i ) &#123;</span><br><span class="line">    sum[i] = <span class="number">1ll</span> * ( sum[i<span class="number">-1</span>] + phi[i] );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n; ll ans = <span class="number">0</span>; <span class="built_in">scanf</span> ( <span class="string">&quot;%lld&quot;</span>, &amp;n );</span><br><span class="line">  <span class="built_in">prime</span> ( n );</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> d = <span class="number">1</span>, r; d &lt;= n; d = r + <span class="number">1</span> ) &#123;</span><br><span class="line">    <span class="keyword">int</span> t = n / d; r = n / t;</span><br><span class="line">    ans += t * t * ( sum[r] - sum[d<span class="number">-1</span>] );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><h3 id="简单性质-1"><a href="#简单性质-1" class="headerlink" title="简单性质"></a>简单性质</h3><ol>
<li>与乘法卷积的关系： $\mu * I = \varepsilon$<br>即 $\sum_{d|n} \mu(d) = [n == 1]$<br>也就是莫比乌斯反演。这个东西和上面欧拉函数的式子挺像的。其实它俩的用途也差不多。  </li>
<li>如果 $p | n$ 并且 $p ^ 2 | n$ ， $\mu(n) = -\mu(p)$ ； 如果 $p | n$ 并且 $p ^ 2 \nmid n$ ， $\mu(n) = 0$ 。</li>
</ol>
<h3 id="线性筛求-mu"><a href="#线性筛求-mu" class="headerlink" title="线性筛求 $\mu$"></a>线性筛求 $\mu$</h3><p>和求 $\varphi$ 类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数论初步 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      vis[i] = i, p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * p[j] &gt; n || p[j] &gt; vis[i])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      vis[i * p[j]] = p[j];</span><br><span class="line">      <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><script type="math/tex; mode=display">
\sum_{i = 1} ^ n \sum_{j = 1} ^ m [gcd (i, j) == t]</script><p>一个比较经典的应用。</p>
<p>具体实现：</p>
<script type="math/tex; mode=display">
\sum_{i = 1} ^ {\left\lfloor n/t \right\rfloor} \sum_{j = 1} ^ {\left\lfloor m/t \right\rfloor} [gcd (i, j) == 1]</script><script type="math/tex; mode=display">
\sum_{i = 1} ^ {\left\lfloor n/t \right\rfloor} \sum_{j = 1} ^ {\left\lfloor m/t \right\rfloor} \sum_{d | gcd(i, j)} \mu(d)</script><p>交换求和顺序</p>
<script type="math/tex; mode=display">
\sum_d \sum_{i = 1} ^ {\left\lfloor n/dt \right\rfloor} \sum_{j = 1} ^ {\left\lfloor m/dt \right\rfloor} \mu(d)</script><p>然后套个整除分块。</p>
<p><a href="https://www.luogu.com.cn/problem/P3455">P3455 [POI2007]ZAP-Queries</a>:</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数论初步 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> IO <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[Maxn], vis[Maxn], cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn], sum[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      vis[i] = i, p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * p[j] &gt; n || p[j] &gt; vis[i])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      vis[i * p[j]] = p[j];</span><br><span class="line">      <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="built_in">read</span> (), b = <span class="built_in">read</span> (), d = <span class="built_in">read</span> ();</span><br><span class="line">  a /= d, b /= d;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= <span class="built_in">min</span> (a, b); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = <span class="built_in">min</span> (a / (a / l), b / (b / l));</span><br><span class="line">    ans += <span class="number">1ll</span> * (sum[r] - sum[l - <span class="number">1</span>]) * (a / l) * (b / l);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">prime</span> (<span class="number">5e4</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (<span class="keyword">int</span>)<span class="number">5e4</span>; ++i)</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">  <span class="keyword">int</span> t = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">work</span> ();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To Be Continued;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>整体二分 学习笔记</title>
    <url>/Home/Overall-Dichotomy/</url>
    <content><![CDATA[<h1 id="整体二分-学习笔记"><a href="#整体二分-学习笔记" class="headerlink" title="整体二分 学习笔记"></a>整体二分 学习笔记</h1><p>整体二分可以实现的功能相较于 CDQ 分治来说就比较局限了，它可以实现 <strong>动态区间第 $k$ 小</strong>。</p>
<span id="more"></span>
<p>思想大概是通过不断地二分值域，最终将每个操作归到一个点上，当前点即为查询的答案。</p>
<p>实质上就是<strong>将 $n$ 个二分同时进行</strong>。</p>
<p>对操作进行重排时使用两个临时数组进行辅助。</p>
<p>具体实现：</p>
<ul>
<li><p>将所有的插入、修改和查询操作放在同一个结构体数组中。结构体维护一下几个信息：</p>
<p>$tp$ - 当前操作的性质；修改为 0 ，查询为 1<br>$p, v, x$ - 如果当前操作为修改，$p$ 表示要修改的位置，$v$ 表示”变化”的值， $x$ 表示加（1）减（-1）。<br>$id, l, r, k$ - 如果当前操作为查询，$id$ 表示当前操作作为一个询问的编号，要找 $[l, r]$ 中第 $k$ 小。</p>
</li>
<li><p>插入和查询没什么可写的。修改转化为先删除再插入即可。</p>
</li>
<li><p>每次二分值域，<strong>依次（顺序很重要）</strong>枚举当前值域区间所有的操作，归为一下 4 类：</p>
<ol>
<li><p>修改，要修改的权值小于 $mid$ ，将要修改的位置在树状数组上打标记。同时将当前操作插入左区间临时数组。</p>
</li>
<li><p>修改，要修改的权值大于 $mid$ ，直接放在右区间临时数组即可。</p>
</li>
<li><p>查询，$k$ 值小于左区间所有<strong>已经放入</strong>的值 $s$，他要找的答案一定在左区间，直接插入左区间。</p>
</li>
<li><p>查询，$k$ 值大于左区间所有已经放入的值 $s$，答案一定在右区间，查询右区间 $k - s$ 值。</p>
</li>
</ol>
</li>
<li><p>对树状数组进行恢复，合并回主数组，进行下一次分治。</p>
</li>
</ul>
<p>这段意思是，统计<strong>某次查询前</strong>左区间数的个数，然后进行类似二分的套路操作。</p>
<pre><code>代码实现：
</code></pre><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整体二分 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>, inf = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;</span><br><span class="line"><span class="keyword">int</span> v[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x &lt; Maxn; x += (x &amp; -x))</span><br><span class="line">    v[x] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> ans = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; x; x -= (x &amp; -x))</span><br><span class="line">    ans += v[x];</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace BIT</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> BIT;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tp;           <span class="comment">// 用来标记操作类型</span></span><br><span class="line">  <span class="keyword">int</span> p, v, x;      <span class="comment">// 用来维护修改操作</span></span><br><span class="line">  <span class="keyword">int</span> id, l, r, k;  <span class="comment">// 用来维护查询操作</span></span><br><span class="line">&#125; q[Maxn &lt;&lt; <span class="number">1</span>], q1[Maxn &lt;&lt; <span class="number">1</span>], q2[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot, tq, ans[Maxn], a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r || ql &gt; qr) <span class="keyword">return</span>;                 <span class="comment">// 判断不合法区间</span></span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;                                 <span class="comment">// 已经将范围缩至某一确定点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i)              <span class="comment">// 遍历所有操作</span></span><br><span class="line">        <span class="keyword">if</span> (q[i].tp)                            <span class="comment">// 判断是否为查询</span></span><br><span class="line">          ans[q[i].id] = l;                     <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = ql; i &lt;= qr; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (q[i].tp) &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">ask</span> (q[i].r) - <span class="built_in">ask</span> (q[i].l - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (q[i].k &lt;= s)                          <span class="comment">// 类型 3</span></span><br><span class="line">        q1[++c1] = q[i];</span><br><span class="line">      <span class="keyword">else</span>                                      <span class="comment">// 类型 4</span></span><br><span class="line">        q[i].k -= s, q2[++c2] = q[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里不要把 v 和 p 搞反</span></span><br><span class="line">      <span class="keyword">if</span> (q[i].v &lt;= mid)                        <span class="comment">// 类型 1</span></span><br><span class="line">        q1[++c1] = q[i], <span class="built_in">add</span> (q[i].p, q[i].x);</span><br><span class="line">      <span class="keyword">else</span> q2[++c2] = q[i];                     <span class="comment">// 类型 2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c1; ++i)                 <span class="comment">// 恢复现场</span></span><br><span class="line">    <span class="keyword">if</span> (!q1[i].tp)</span><br><span class="line">      <span class="built_in">add</span> (q1[i].p, -q1[i].x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c1; ++i)                 <span class="comment">// 合并数组</span></span><br><span class="line">    q[i + ql - <span class="number">1</span>] = q1[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c2; ++i)</span><br><span class="line">    q[i + ql + c1 - <span class="number">1</span>] = q2[i];</span><br><span class="line">  <span class="built_in">solve</span> (l, mid, ql, ql + c1 - <span class="number">1</span>);              <span class="comment">// 进行下一步分治</span></span><br><span class="line">  <span class="built_in">solve</span> (mid + <span class="number">1</span>, r, ql + c1, qr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> (), m = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    q[++tot] = (node) &#123;<span class="number">0</span>, i, a[i] = <span class="built_in">read</span> (), <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, k; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> c; cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      l = <span class="built_in">read</span> (), r = <span class="built_in">read</span> (), k = <span class="built_in">read</span> ();</span><br><span class="line">      q[++tot] = (node) &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ++tq, l, r, k&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="built_in">read</span> (), y = <span class="built_in">read</span> ();</span><br><span class="line">      q[++tot] = (node) &#123;<span class="number">0</span>, x, a[x], <span class="number">-1</span>&#125;;</span><br><span class="line">      <span class="comment">// 这里及时修改 a 数组的值</span></span><br><span class="line">      q[++tot] = (node) &#123;<span class="number">0</span>, x, a[x] = y, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve</span> (-inf, inf, <span class="number">1</span>, tot);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tq; ++i)</span><br><span class="line">    <span class="built_in">print</span> (ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>D&amp;C</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式 学习笔记</title>
    <url>/Home/Polynomial/</url>
    <content><![CDATA[<p>我是真的没想到，有很多地方不是独立完成的，但这篇博客仍写了 1 天。</p>
<p>还有它貌似是 22 年的第一篇博客。</p>
<span id="more"></span>
<h1 id="多项式-学习笔记"><a href="#多项式-学习笔记" class="headerlink" title="多项式 学习笔记"></a>多项式 学习笔记</h1><p>多项式的定义与数学中的定义相同，这里指的多项式均为<strong>一元多项式</strong>。</p>
<h2 id="多项式基本知识"><a href="#多项式基本知识" class="headerlink" title="多项式基本知识"></a>多项式基本知识</h2><h3 id="多项式的表达"><a href="#多项式的表达" class="headerlink" title="多项式的表达"></a>多项式的表达</h3><p>在计算机中， 多项式有两种常见的表达方式，点值表达和系数表达。</p>
<ul>
<li>系数表达：指用 $n + 1$ 个数来表示一个 $n$ 次多项式。其中 $a_k,k\in[0, n]$ 分别表示该多项式的 $k$ 次项系数。</li>
<li>点值表达：<strong>代数基本定理</strong>中说明：$n$ 个<strong>不同</strong>点可以表示一个<strong>唯一确定</strong>的 $n - 1$ 次多项式。这里只讨论用一些<strong>有特性的点</strong>来表示一个多项式，所以横坐标是可以根据下标推出来的，$a_0, \dots a_n$ 分别表示第 $k$ 个点的纵坐标。</li>
</ul>
<h3 id="多项式的界"><a href="#多项式的界" class="headerlink" title="多项式的界"></a>多项式的界</h3><p>大多数情况下我们只需要在意低次项，一个多项式的界就代表最高有用位。</p>
<h3 id="多项式的四则运算"><a href="#多项式的四则运算" class="headerlink" title="多项式的四则运算"></a>多项式的四则运算</h3><p>加减法运算：</p>
<ul>
<li>系数表达下：直接系数相加减即可</li>
<li>点值表达下：直接纵坐标相加减即可。</li>
</ul>
<p>乘法运算：</p>
<ul>
<li><p>系数表达下：本质上是加法卷积，令 $f[k]$ 表示多项式 $f$ 的 $k$ 次项系数。式子是：</p>
<script type="math/tex; mode=display">C[k] = \sum_{i + j = k} A[i] \times b[j]</script></li>
<li><p>点值表达下：直接 $c_k = a_k \times b_k$ 即可。</p>
</li>
</ul>
<p>求逆运算：</p>
<p>较为复杂，待会分析。</p>
<h2 id="多项式半家桶"><a href="#多项式半家桶" class="headerlink" title="多项式半家桶"></a>多项式半家桶</h2><h3 id="从-FFT-到-NTT-，点值表达与系数表达的转换。"><a href="#从-FFT-到-NTT-，点值表达与系数表达的转换。" class="headerlink" title="从 $FFT$ 到 $NTT$ ，点值表达与系数表达的转换。"></a>从 $FFT$ 到 $NTT$ ，点值表达与系数表达的转换。</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>从多项式的乘法就可以看出，某些情况下点值表达比系数表达要方便，但有些情况下又必须用系数表达。所以如何将这两种表达方式串联起来，做到快速转化便是主要问题。</p>
<p>考虑到点值表达和系数表达都可以看作 <strong>1 行 n 列</strong>的矩阵，转化相当于对他们进行线性变换。如果可以找到一些特殊的点，那么就可以用<strong>分治</strong>来代替暴力以降低复杂度。</p>
<p>数学界某知名大佬 Fourier 找到了一类符合条件的数：<strong>单位根</strong>（$\omega$）。</p>
<h4 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h4><p>单位根是指<strong>复数域</strong>单位圆上的点。$n$ 次单位根 $\omega_n^1$ 本质上是 $\omega_n^1 = \sqrt[n]{1}$ 。</p>
<p>这个东西的某些性质和三角函数很像。（毕竟都是圆上的东西）</p>
<p>具体来说：</p>
<ol>
<li>$\omega_n^m = (\omega_n^1)^{m\%n}$</li>
<li>$\omega_n^j \times \omega_n^k = w^{j + k}$</li>
<li>$\omega_{2n}^{2m} = w_n^m$</li>
<li>$\omega_n^{k+n/2} = -\omega_n^k$</li>
</ol>
<p>有了上面的性质，就可以暴力推式子了。</p>
<h4 id="DFT-的推导"><a href="#DFT-的推导" class="headerlink" title="DFT 的推导"></a>DFT 的推导</h4><p>设 $F(x)$ 的项数是 $2$ 的整次幂（不是的暴力补高位为 0 就行） 将 $F(x)$ 按照奇偶性劈成两半：$F(x) = (F[0] + F[2]x^2 + F[n - 2]x^{n - 2}) + (F[1]x + f[3]x^3 + f[n - 1]x^{n - 1})$ 。</p>
<p>设：</p>
<script type="math/tex; mode=display">Fl(x) = \sum F[2k]x^{k}, Fr(x) = \sum F[2k + 1]x^k ,k \in [0, n / 2 - 1]</script><p>可以发现：</p>
<script type="math/tex; mode=display">F(x) = Fl(x ^ 2) + x\cdot Fr(x^2)</script><p>按照上下半圆分别带入单位根：</p>
<ul>
<li><p>当 $k &lt; n / 2$ 时，代入 $\omega^k_n$</p>
<script type="math/tex; mode=display">F(\omega^k_n) = Fl(\omega^k_{n / 2}) + \omega^k_n Fr(\omega^k_{n / 2})</script></li>
<li><p>当 $k &gt; n / 2$ 时，设 $t = k - n / 2$ ，代入 $\omega^t_n$</p>
<script type="math/tex; mode=display">F(w^{t + n / 2}_n) = Fl(w^t_{n / 2}) - w^t_n Fr(\omega^t_{n / 2})</script></li>
</ul>
<p>单看这个式子并不能看出什么，但是如果<strong>无限分治</strong>下去就可以得出答案。</p>
<h4 id="IDFT-的实现"><a href="#IDFT-的实现" class="headerlink" title="IDFT 的实现"></a>IDFT 的实现</h4><p>本质上是单位根反演，没学那么多也写不了那么详细，直接把式子放在这里：</p>
<p>设 $G = DFT(F)$ ，则 $G[k] = \sum_{i = 0}^ {n - 1} (\omega^k_n)^i F[i]$</p>
<script type="math/tex; mode=display">n\cdot F[k] = \sum_{i = 0}^{n - 1} (\omega^{-k}_n)G[i]</script><h4 id="细节优化"><a href="#细节优化" class="headerlink" title="细节优化"></a>细节优化</h4><p>可以发现 $DFT$ 和 $IDFT$ 分治起来只差一个负号，所以可以共用一个函数，并附带一个 $bool$ 型参数。</p>
<p>同时可以发现每个长度为 $n$ 的多项式对应的每个点的位置在开始之前都是<strong>唯一确定且已知</strong>的。所以可以<strong>线性预处理</strong>一下。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><a href="https://www.luogu.com.cn/problem/P3803">P3803 【模板】多项式乘法（FFT）</a></p>
<p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>); c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_n</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">print_n</span>(x / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> s = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">  <span class="built_in">print_n</span>(x), <span class="built_in">putchar</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1.5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CP</span> &#123;</span></span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">  <span class="built_in">CP</span> (<span class="keyword">double</span> tx = <span class="number">0</span>, <span class="keyword">double</span> ty = <span class="number">0</span>) &#123;</span><br><span class="line">    x = tx, y = ty;</span><br><span class="line">  &#125;</span><br><span class="line">  CP <span class="keyword">operator</span>+ (CP <span class="keyword">const</span>&amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CP</span> (x + B.x, y + B.y);</span><br><span class="line">  &#125;</span><br><span class="line">  CP <span class="keyword">operator</span>- (CP <span class="keyword">const</span>&amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CP</span> (x - B.x, y - B.y);</span><br><span class="line">  &#125;</span><br><span class="line">  CP <span class="keyword">operator</span>* (CP <span class="keyword">const</span>&amp; B) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CP</span> (x * B.x - y * B.y, x * B.y + y * B.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; f[Maxn &lt;&lt; <span class="number">1</span>], g[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tr[Maxn &lt;&lt; <span class="number">1</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span> <span class="params">(CP *f, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; tr[i]) <span class="built_in">swap</span> (f[i], f[tr[i]]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= n; p &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = p &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="function">CP <span class="title">tG</span><span class="params">(cos(<span class="number">2</span> * Pi / p), sin (<span class="number">2</span> * Pi / p))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) tG.y *= <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k += p) &#123;</span><br><span class="line">      <span class="function">CP <span class="title">buf</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &lt; k + len; ++l) &#123;</span><br><span class="line">        CP tt = buf * f[len + l];</span><br><span class="line">        f[len + l] = f[l] - tt;</span><br><span class="line">        f[l] = f[l] + tt;</span><br><span class="line">        buf = buf * tG;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span> () + <span class="number">1</span>, m = <span class="built_in">read</span> () + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lf&quot;</span>, &amp;f[i].x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lf&quot;</span>, &amp;g[i].x);</span><br><span class="line">  <span class="keyword">for</span> (m += n, n = <span class="number">1</span>; n &lt; m; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    tr[i] = (tr[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) ? n &gt;&gt; <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">fft</span> (f, <span class="number">1</span>), <span class="built_in">fft</span> (g, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    f[i] = f[i] * g[i];</span><br><span class="line">  <span class="built_in">fft</span> (f, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, (<span class="keyword">int</span>) (f[i].x / n + <span class="number">0.49</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剩余系，原根与-NTT"><a href="#剩余系，原根与-NTT" class="headerlink" title="剩余系，原根与 $NTT$"></a>剩余系，原根与 $NTT$</h4><p>前置知识略解：</p>
<ul>
<li><p>阶：最小的 $k$ 满足 $a^k \equiv 1\bmod p$，记为 $\delta_pa$</p>
</li>
<li><p>原根：最大的 $g$ 满足 $\delta_pg = \varphi(p)$ </p>
</li>
</ul>
<p>$FFT$ 好是好，但是由于用到了复数，常数巨大且容易丢精度。</p>
<p>所以就要找一些东西来代替单位根。但是实数域已经找不到可以替代的东西了。但好在大多数时候研究问题是在剩余系中，然后就有东西可以代替了。且一般模数都是 $998244353 = 2^{23} \cdot 7 \cdot 17 + 1$ 考虑到原根的性质，可以支持找到一个单位根满足条件，即 $g^{\small\tfrac{p - 1}{n}}$ 。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>  代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NTT 多项式转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span> <span class="params">(<span class="keyword">int</span> *g, <span class="keyword">int</span> n, <span class="keyword">bool</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> ull f[Maxn &lt;&lt; <span class="number">1</span>];                      <span class="comment">// 用宏定义来避免命名冲突</span></span><br><span class="line">  <span class="built_in">tpre</span> (n);                                     <span class="comment">// 预处理顺序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    f[i] = g[tr[i]];                            <span class="comment">// 调整数组顺序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= n; p &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = p &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ull tG = <span class="built_in">Pow</span> (op ? G : invG, (P - <span class="number">1</span>) / p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k += p) &#123;</span><br><span class="line">      <span class="keyword">int</span> buf = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> l = k; l &lt; k + len; ++l) &#123;</span><br><span class="line">        <span class="keyword">int</span> tt = buf * f[l | len] % P;</span><br><span class="line">        f[l | len] = (f[l] - tt + P) % P;</span><br><span class="line">        f[l] = (f[l] + tt + P) % P;</span><br><span class="line">        buf = buf * tG % P;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;                                 <span class="comment">// 根据 DFT 还是 IDFT 来进行下一步操作</span></span><br><span class="line">    ull invn = <span class="built_in">Pow</span> (n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) g[i] = f[i] * invn % P;</span><br><span class="line">  &#125; <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) g[i] = f[i] % P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式的求导，积分"><a href="#多项式的求导，积分" class="headerlink" title="多项式的求导，积分"></a>多项式的求导，积分</h3><p>一定要记住，这两个的结果都是<strong>一个多项式</strong>，而不是一个值</p>
<h4 id="多项式求导（通俗理解就是求斜率）"><a href="#多项式求导（通俗理解就是求斜率）" class="headerlink" title="多项式求导（通俗理解就是求斜率）"></a>多项式求导（通俗理解就是求斜率）</h4><p>它的数学求法为 $\forall x1, x2 \in M , \text{令} \Delta x = x2 - x1, \text{则} f’(x1) = \dfrac{f(x1 + \Delta x) - f(x1)}{\Delta x}$</p>
<p>用系数就是：</p>
<script type="math/tex; mode=display">F'(x) = \sum_{i = 0} F[i]x^i\cdot \dfrac{i}{x} \\ \Rightarrow F'(x) = \sum_{i = 0} F[i]x^{i - 1}\cdot i</script><p>可以得出的结论是一个 $n$ 次多项式的导数是一个 $n - 1$ 次多项式。</p>
<h4 id="多项式积分（通俗理解就是求面积）"><a href="#多项式积分（通俗理解就是求面积）" class="headerlink" title="多项式积分（通俗理解就是求面积）"></a>多项式积分（通俗理解就是求面积）</h4><script type="math/tex; mode=display">\int(x) = C + \sum_{i = 0}F[i]x^i \cdot \dfrac{x}{i} \\ \Rightarrow\int(x) = C + \sum_{i = 0} \dfrac{F[i]x^{i + 1}}{i}</script><h4 id="更好地理解"><a href="#更好地理解" class="headerlink" title="更好地理解"></a>更好地理解</h4><p>如果上面不理解，可以类比一下物理学 $x - t，  v - t, a - t$ 关系式。</p>
<p> 一个 $v - t$ 关系式的积分是 $x - t$ 关系式，导数是 $a - t$ 关系式。如果 $v - t$ 为 1 次，那么 $x - t$ 为 2 次；如果 $v - t$ 关系式为 2 次，那么 $a - t$ 为 1 次。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多项式求导</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">der</span> <span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    f[i - <span class="number">1</span>] = <span class="number">1ll</span> * f[i] * i % P;</span><br><span class="line">  &#125; f[n - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多项式积分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inte</span> <span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i) &#123;</span><br><span class="line">    f[i] = <span class="number">1ll</span> * f[i - <span class="number">1</span>] * <span class="built_in">Pow</span> (i, P - <span class="number">2</span>) % P;</span><br><span class="line">  &#125; f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多项式的复合-牛顿迭代"><a href="#多项式的复合-牛顿迭代" class="headerlink" title="多项式的复合 - 牛顿迭代"></a>多项式的复合 - 牛顿迭代</h3><p>这个东西不会证。他不是某个函数，更像是帮你推导式子的一种工具，需要配合倍增使用。</p>
<p>具体来说就是当 $G$ 已知且 $G(f(x)) = 0$ 时，$F(x) \equiv F_*(x) - \dfrac{G(F_*(x))}{G’(F_*(x))}\bmod x^n$ 。</p>
<p>其中 $F_*(x)$ 表示上一次倍增的结果，界为 $F(x)$ 的 $\dfrac{1}{2}$ 的多项式，$G$ 一般是构造出来的。</p>
<h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>这个东西有三种求法：朴素求法，倍增大力推式子，倍增牛顿迭代。</p>
<h4 id="朴素求法"><a href="#朴素求法" class="headerlink" title="朴素求法"></a>朴素求法</h4><p>考虑逆元的性质，设 $F(x)$ 为已知多项式 $G(x)$ 为要求的逆多项式。</p>
<script type="math/tex; mode=display">C(k) = \sum_{i = 0}^k F[i]G[k - i]</script><p>只有 $C$ 的第 $0$ 位为 1 。即当目前不是常数时 </p>
<script type="math/tex; mode=display">\sum_{i = 0}^n F[i]G[n - i] = 0</script><p>将 $F[0]G[n]$ 单拎出来，</p>
<script type="math/tex; mode=display">\sum_{i = 1}^n F[i]G[n - i] + F[0]G[n] = 0</script><p>移向消元：</p>
<script type="math/tex; mode=display">G[n] = -\dfrac{1}{F[0]}\cdot \sum_{i = 1}^n F[i]G[n - i]</script><p>这样每次求末项，逐步求出的多项式 $G$ 就是 $F$ 的逆多项式。</p>
<h4 id="倍增解法"><a href="#倍增解法" class="headerlink" title="倍增解法"></a>倍增解法</h4><p>考虑当前要求界为 $n$ 意义下的逆多项式 $R(x)$ ，已经求出了界为 $\dfrac{n}{2}$ 的逆多项式 $R_*(x)$ 。</p>
<p>则当前两个多项式满足 </p>
<script type="math/tex; mode=display">R(x) \equiv R_*(x)\bmod x^{\tfrac{n}{2}}</script><p>移项</p>
<script type="math/tex; mode=display">R(x) - R_*(x) \equiv 0 \bmod x^ {\tfrac{n}{2}}</script><p>乘方，扩界</p>
<script type="math/tex; mode=display">(R(x) - R_*(x))^2 \equiv 0 \bmod x^n</script><p>拆括号，移相，两边同乘 $F(x)$</p>
<script type="math/tex; mode=display">R(x) \equiv 2R_*(x) - R_*^2F(x) \bmod x^n</script><h4 id="牛顿迭代解法"><a href="#牛顿迭代解法" class="headerlink" title="牛顿迭代解法"></a>牛顿迭代解法</h4><p>这个方法推出来的式子和上面是一样的，只是换一种推导思路而已。</p>
<script type="math/tex; mode=display">F(x)R(x) - 1 \equiv 0 \bmod P</script><p>设 $F(x)R(x) - 1$ 为 $G$ ， 其中 $F(x)$ 已知，可以作为一个系数。下面逐步推导即可。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多项式求逆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invp</span> <span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m = n;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> w[Maxn &lt;&lt; <span class="number">1</span>], r[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; m; n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">  w[<span class="number">0</span>] = <span class="built_in">Pow</span> (f[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; len &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">      r[i] = w[i];</span><br><span class="line">    <span class="built_in">cpy</span> (sav, f, len);</span><br><span class="line">    <span class="built_in">ntt</span> (sav, len, <span class="number">1</span>), <span class="built_in">ntt</span> (r, len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">px</span> (r, sav, len), <span class="built_in">ntt</span> (r, len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">clear</span> (r, <span class="number">0</span>, len &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cpy</span> (sav, w, len);</span><br><span class="line">    <span class="built_in">ntt</span> (sav, len, <span class="number">1</span>), <span class="built_in">ntt</span> (r, len, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">px</span> (r, sav, len), <span class="built_in">ntt</span> (r, len, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len &gt;&gt; <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">      w[i] = (<span class="number">2ll</span> * w[i] - r[i] + P) % P;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cpy</span> (f, w, m);</span><br><span class="line">  <span class="built_in">clear</span> (sav, <span class="number">0</span>, n), <span class="built_in">clear</span> (w, <span class="number">0</span>, n), <span class="built_in">clear</span> (r, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树，可持久化权值线段树，树套树 学习笔记</title>
    <url>/Home/Segment-Tree/</url>
    <content><![CDATA[<h1 id="线段树，可持久化权值线段树，树套树-学习笔记"><a href="#线段树，可持久化权值线段树，树套树-学习笔记" class="headerlink" title="线段树，可持久化权值线段树，树套树 学习笔记"></a>线段树，可持久化权值线段树，树套树 学习笔记</h1><p>update: 2021-12-25 进行了一些简单修改和维护。</p>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>时间复杂度：$O(nlogn)$</p>
<p>线段树是一种用来动态维护区间和，区间积，区间极值等区间信息的数据结构，它是建立在分治思想上的。</p>
<span id="more"></span>
<p>具体实现：</p>
<ul>
<li>建立一个结构体来表示这颗线段树，结构体的每个点是这个线段树的节点，它需要维护以下几个信息：<ol>
<li>$l,r$ 用来维护这个节点所表示的区间，其中设当前节点表示的区间为 $[l,r]$ ，$mid = l + r &gt;&gt; 1$ ，则左子节点表示的区间为 $[l,mid]$ ，右子节点表示的区间为 $[mid+1,r]$ 。</li>
<li>$ls, rs$ 即这个节点左右子节点的下标。</li>
<li>根据需要维护 $Sum, Max, Min$ 等信息。</li>
<li>以上前两条可以根据个人代码习惯省略。</li>
</ol>
</li>
<li>$pushup$ 操作：用来把子节点的信息<strong>上传给父节点</strong></li>
<li>$build$ 操作：用来建立左右子节点，以及统计初始信息，如无特殊要求 $ls$ 即为 $\text{当前节点的下标} \times 2$ ，$rs$ 即为 $\text{当前节点的下标} \times 2 + 1$ 。</li>
<li>$change$ 操作：用来区间修改统计的信息。其中，要修改的区间要 <strong>“沉降”</strong> 在各个节点上。即，如果 $[l_x,r_x] \in [L,R]$ 就直接修改 $x$ 这个节点，并打上<strong>懒惰标记</strong>，懒惰标记等到要<strong>用子节点的信息时</strong>再下放，来保证修改操作<strong>时间复杂度的正确性</strong>。否则单次修改操作时间复杂度会被卡成 $O(n)$ 。</li>
<li>$spread$ 操作：用来下方懒惰标记，具体实现因统计的数据而异。</li>
<li>$ask$ 操作：用来统计区间信息，与修改操作类似，将要询问的区间<strong>“沉降”</strong>在树上。要注意向下递归时先下放标记。</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P3373">P3373 [模板]线段树 2</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线段树，可持久化权值线段树，树套树 学习笔记</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面是曾经错过的点：</span></span><br><span class="line"><span class="comment">每次更改要修改标记而不是直接覆盖</span></span><br><span class="line"><span class="comment">不要忘记每次上传数据</span></span><br><span class="line"><span class="comment">大写的 P 和小写的 p 要分清,不要对小 p 取模</span></span><br><span class="line"><span class="comment">更新 add 标记比较特殊要先将 add_s*mu_f 再 +add_f</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> P = <span class="number">571373</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line"><span class="comment">// 结构体封装线段树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r; ll val, add, mu;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].val</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ad(x) St[x].add</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> mu(x) St[x].mu</span></span><br><span class="line">&#125; St[Maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 下传标记，注意本题由于既有乘法标记，又有加法标记，所以要注意下传顺序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span> <span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ad</span>(ls) = (<span class="built_in">ad</span>(ls) * <span class="built_in">mu</span>(p) + <span class="built_in">ad</span>(p)) % P;                              <span class="comment">// 先更新子节点加法标记</span></span><br><span class="line">  <span class="built_in">ad</span>(rs) = (<span class="built_in">ad</span>(rs) * <span class="built_in">mu</span>(p) + <span class="built_in">ad</span>(p)) % P;</span><br><span class="line">  <span class="built_in">mu</span>(ls) = <span class="built_in">mu</span>(ls) * <span class="built_in">mu</span>(p) % P;                                        <span class="comment">// 后更新子节点乘法标记</span></span><br><span class="line">  <span class="built_in">mu</span>(rs) = <span class="built_in">mu</span>(rs) * <span class="built_in">mu</span>(p) % P;</span><br><span class="line">  <span class="built_in">v</span>(ls) = (<span class="built_in">v</span>(ls) * <span class="built_in">mu</span>(p) % P + <span class="number">1ll</span> * <span class="built_in">ad</span>(p) * (<span class="built_in">r</span>(ls) - <span class="built_in">l</span>(ls) + <span class="number">1</span>)) % P;<span class="comment">// 最后更新子节点权值</span></span><br><span class="line">  <span class="built_in">v</span>(rs) = (<span class="built_in">v</span>(rs) * <span class="built_in">mu</span>(p) % P + <span class="number">1ll</span> * <span class="built_in">ad</span>(p) * (<span class="built_in">r</span>(rs) - <span class="built_in">l</span>(rs) + <span class="number">1</span>)) % P;</span><br><span class="line">  <span class="built_in">mu</span>(p) = <span class="number">1</span>, <span class="built_in">ad</span>(p) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建树函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r; <span class="built_in">mu</span>(p) = <span class="number">1</span>;<span class="comment">// 确定左右端点，同时初始化乘法标记</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) = a[<span class="built_in">l</span>(p)]; <span class="keyword">return</span>;     <span class="comment">// 确定叶子节点初值</span></span><br><span class="line">  &#125; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span> (ls, l, mid);           <span class="comment">// 递归构建左子树</span></span><br><span class="line">  <span class="built_in">build</span> (rs, mid + <span class="number">1</span>, r);       <span class="comment">// 递归构建右子树</span></span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);         <span class="comment">// 统计子节点信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加法操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;                     <span class="comment">// 如果完全被包含直接沉降</span></span><br><span class="line">    <span class="built_in">v</span>(p) = <span class="built_in">v</span>(p) + <span class="number">1ll</span> * k * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>) % P;  <span class="comment">// 更新当前节点权值</span></span><br><span class="line">    (<span class="built_in">ad</span>(p) += k) %= P; <span class="keyword">return</span>;                      <span class="comment">// 打标记</span></span><br><span class="line">  &#125; <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">spread</span> (p);                                       <span class="comment">// 既然执行到这一步，说明当前节点的子节点要被访问（否则上面 if 语句已经回溯），需要先下传标记</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">add</span> (ls, l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">add</span> (rs, l, r, k);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 乘法操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">times</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, ll k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) = <span class="built_in">v</span>(p) * k % P; <span class="built_in">ad</span>(p) = <span class="built_in">ad</span>(p) * k % P;</span><br><span class="line">    <span class="built_in">mu</span>(p) = <span class="built_in">mu</span>(p) * k % P; <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">spread</span> (p);</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">times</span> (ls, l, r, k);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">times</span> (rs, l, r, k);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="function">ll <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">v</span>(p);          <span class="comment">// 如果完全被包含直接返回</span></span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">spread</span> (p);                                       <span class="comment">// 否则需要用到子节点信息，下传标记</span></span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) (ans += <span class="built_in">ask</span> (ls, l, r)) %= P;       <span class="comment">// 统计左节点答案</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) (ans += <span class="built_in">ask</span> (rs, l, r)) %= P;        <span class="comment">// 统计右节点答案</span></span><br><span class="line">  <span class="keyword">return</span> ans;                                       <span class="comment">// 返回答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, p; </span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;p);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  <span class="built_in">build</span> (<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l, r, opt; ll k;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">times</span> (<span class="number">1</span>, l, r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;k);</span><br><span class="line">      <span class="built_in">add</span> (<span class="number">1</span>, l, r, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span> (<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>时间复杂度：$O(nlogn)$</p>
<p>权值线段树是用来维护一个值域上的数的存在信息，相对于普通线段树来将代码量较小，但用处也不少。最经典的应用是静态全局第 k 小。</p>
<p>具体实现：</p>
<ul>
<li>要维护的信息：这个节点的左，右子节点（应为权值线段树可能会用到<strong>动态开点</strong>，所以记录左右子节点相对重要）</li>
<li>$build$ 操作：与上面类似。$ls, rs$ 的建立根据要求和值域范围修改。</li>
<li>$change$ 操作：权值线段树一般不要求区间修改，可以直接单点修改。</li>
<li>$ask$ 操作：$ask$ 操作在权值线段树上的含义是在 $[L,R]$ 范围内的数有多少个，一般不是很常用。</li>
<li>$find$ 操作：相当于线段树上二分，这个操作只有在权值线段树上才有意义，含义是找到 $rank \le k $ 的最大的数。如果要找到当前 $[l, r]$ （均为线段树节点区间）第 $k$ 小，如果左边节点个数能够达到，就在左边递归找，否则在右边递归找第 $k - cnt_l$ 的点</li>
</ul>
<p><a href="https://www.luogu.com.cn/problem/P1923">P1923 【深基9.例4】求第 k 小的数</a>（多少有点大材小用，且过不了）</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线段树，可持久化权值线段树，树套树 学习笔记</span></span><br><span class="line"><span class="comment">// 权值线段树动态开点版</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, val;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) St[x].ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) St[x].rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].val</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 插入权值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++tot;     <span class="comment">// 动态开点</span></span><br><span class="line">  <span class="built_in">v</span>(p) += <span class="number">1</span>;             <span class="comment">// 统计权值</span></span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p;  <span class="comment">// 返回当前节点,以便父节点进行统计</span></span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">    <span class="built_in">ls</span>(p) = <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, mid, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">rs</span>(p) = <span class="built_in">add</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;  <span class="comment">// 如果到达最底层说明找到了</span></span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 现在要找到当前 l, r 第 k 小，如果左边节点个数能够达到，就在左边找，否则在右边找第 k - (cnt_l) 的点</span></span><br><span class="line">  <span class="keyword">if</span> (v &lt;= <span class="built_in">v</span>(<span class="built_in">ls</span>(p)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">ls</span>(p), l, mid, v);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v - <span class="built_in">v</span>(<span class="built_in">ls</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], b[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">read</span>(), b[i] = a[i];</span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    v = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, a[i]) - b;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, n, v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(b[<span class="built_in">find</span>(<span class="number">1</span>, <span class="number">1</span>, n, k)]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可持久化权值线段树"><a href="#可持久化权值线段树" class="headerlink" title="可持久化权值线段树"></a>可持久化权值线段树</h2><p>时间复杂度：$O(nlogn)$</p>
<p>可持久化的权值线段树可以解决静态区间第 k 小问题。</p>
<p>具体实现：</p>
<p>可持久化思想的引入也较好理解，可持久化顾名思义，就是支持<strong>继承某个历史版本并更新</strong>，<strong>注意</strong>主席树这里的历史版本和日常说的历史版本<strong>意义并不相同</strong>，这里的每个历史版本指的都是当前序列的<strong>每个前缀</strong>。</p>
<p>那访问历史版本复制一遍不就行了嘛？为什么还要再写别的东西呢？</p>
<p>主要是考虑数据范围和时空限制。如果每次都复制一遍处理 $10^4$ 级别的数据都很吃力。</p>
<p>所以就要考虑优化，首先，权值线段树的修改操作仅是单点修改，所以每次改动<strong>最多会造成线段树上一条链</strong>，即 $logn$ 个点的变化，所以我们可以依赖于历史版本，仅将需要修改的地方进行修改。并且记录每个版本的根即可。</p>
<p>对于要实现区间第 k 小的权值线段树来讲，每个插入一个数即建立一个新的版本，求 $[L,R]$ 的第 k 小，就<strong>用 $l-1$ 版本和 $r$ 版本相对位置相同的节点的权值做差</strong>即可。其他与一般权值线段树类似。</p>
<p>注意：为了保证权值线段树的时间复杂度正确，一般要提前进行离散化操作，不会的话建议自行百度。</p>
<p><a href="https://www.luogu.com.cn/problem/P3834">P3834 [模板]可持久化线段树 2</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线段树，可持久化权值线段树，树套树 学习笔记</span></span><br><span class="line"><span class="comment">// 可持久化线段树 || 线段树模板</span></span><br><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>); c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_n</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">print_n</span>(x / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> s = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">  <span class="built_in">print_n</span>(x), <span class="built_in">putchar</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], b[Maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, val;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> ls(x) St[x].ls</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> rs(x) St[x].rs</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].val</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用来构建初始局面，不过一般情况下无需使用。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int build(int l, int r) &#123;</span></span><br><span class="line"><span class="comment">  int p = ++tot;         // 动态开点</span></span><br><span class="line"><span class="comment">  if (l == r) return p;  // 最底层回溯</span></span><br><span class="line"><span class="comment">  int mid = l + r &gt;&gt; 1;  // 二分建树</span></span><br><span class="line"><span class="comment">  ls(p) = build(l, mid);</span></span><br><span class="line"><span class="comment">  rs(p) = build(mid + 1, r);</span></span><br><span class="line"><span class="comment">  return p;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用来插入新的权值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> np = ++tot;                   <span class="comment">// 动态开点</span></span><br><span class="line">  St[np] = St[p], <span class="built_in">v</span>(np) ++;         <span class="comment">// 继承上版本信息 || 更新当前版本信息</span></span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> np;</span><br><span class="line">  <span class="comment">// 下面为权值线段树内容</span></span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">    <span class="built_in">ls</span>(np) = <span class="built_in">add</span> (<span class="built_in">ls</span>(p), l, mid, v);<span class="comment">// 递归传参仍要传旧版本，但更新的信息要存在新版本里</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">rs</span>(np) = <span class="built_in">add</span> (<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v);</span><br><span class="line">  <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;             <span class="comment">// 最底层回溯</span></span><br><span class="line">  <span class="keyword">int</span> s = <span class="built_in">v</span>(<span class="built_in">ls</span>(p)) - <span class="built_in">v</span>(<span class="built_in">ls</span>(q));      <span class="comment">// 做差比较，求当前区间</span></span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;           <span class="comment">// 二分查找</span></span><br><span class="line">  <span class="comment">// 下面为权值线段树内容</span></span><br><span class="line">  <span class="keyword">if</span> (k &lt;= s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span> (<span class="built_in">ls</span>(p), <span class="built_in">ls</span>(q), l, mid, k);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span> (<span class="built_in">rs</span>(p), <span class="built_in">rs</span>(q), mid + <span class="number">1</span>, r, k - s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 处理读入</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> (), m = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    a[i] = <span class="built_in">read</span> (), b[i] = a[i];</span><br><span class="line">  <span class="comment">// 离散化 || 构建序列</span></span><br><span class="line">  <span class="built_in">sort</span> (b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; ++i) </span><br><span class="line">    k = <span class="built_in">lower_bound</span> (b + <span class="number">1</span>, b + n + <span class="number">1</span>, a[i]) - b,</span><br><span class="line">    rt[i] = <span class="built_in">add</span> (rt[i - <span class="number">1</span>], <span class="number">1</span>, n, k);</span><br><span class="line">  <span class="comment">// 处理询问</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">read</span> (), r = <span class="built_in">read</span> (), k = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="built_in">print</span> (b[<span class="built_in">ask</span> (rt[r], rt[l - <span class="number">1</span>], <span class="number">1</span>, n, k)]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h2><p>时间复杂度：$O(nlog^2n)$</p>
<p>树套树这里是指树状数组的思想套线段树，可以用解决主席树解决不了的遗憾——动态区间第 k 小。</p>
<p>具体实现：</p>
<p>介于主席树每次都要继承上一版本的思想，如果前面版本被修改了，后面版本必须全部修改，但这样时间复杂度就会退化，所以想要解决动态问题，就必须解决掉后面版本对前面版本的依赖性。</p>
<p>这就要用到树套树的思想，按照树状数组的样子，建 $logn$ 颗线段树。求解时只需要 $logn$ 颗线段树做差。</p>
<p><a href="https://www.luogu.com.cn/problem/P2617">P2617 Dynamic Rankings</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线段树，可持久化权值线段树，树套树 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp; -x</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Opt</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, k;</span><br><span class="line">  <span class="keyword">bool</span> b;</span><br><span class="line">&#125; q[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, sum;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) St[x].ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) St[x].rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(x) St[x].sum</span></span><br><span class="line">&#125; St[Maxn * <span class="number">400</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, rt[Maxn], tmp0[<span class="number">20</span>], tmp1[<span class="number">20</span>], cnt0, cnt1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>&amp; p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!p) p = ++tot;</span><br><span class="line">  <span class="built_in">sum</span>(p) += k;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">ls</span>(p), l, mid, v, k);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">  <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt1; ++i)</span><br><span class="line">    x += <span class="built_in">sum</span>(<span class="built_in">ls</span>(tmp1[i]));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt0; ++i)</span><br><span class="line">    x -= <span class="built_in">sum</span>(<span class="built_in">ls</span>(tmp0[i]));</span><br><span class="line">  <span class="keyword">if</span> (k &lt;= x) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt1; ++i)</span><br><span class="line">      tmp1[i] = <span class="built_in">ls</span>(tmp1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt0; ++i)</span><br><span class="line">      tmp0[i] = <span class="built_in">ls</span>(tmp0[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(l, mid, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt1; ++i)</span><br><span class="line">      tmp1[i] = <span class="built_in">rs</span>(tmp1[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt0; ++i)</span><br><span class="line">      tmp0[i] = <span class="built_in">rs</span>(tmp0[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span>(mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Cnt, a[Maxn], b[Maxn &lt;&lt; <span class="number">1</span>], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + Cnt + <span class="number">1</span>, a[x]) - b;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">    <span class="built_in">add</span>(rt[i], <span class="number">1</span>, Cnt, k, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(tmp0, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp0));</span><br><span class="line">  <span class="built_in">memset</span>(tmp1, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tmp1));</span><br><span class="line">  cnt0 = cnt1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    tmp1[++cnt1] = rt[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l - <span class="number">1</span>; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">    tmp0[++cnt0] = rt[i];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>, Cnt, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    b[++Cnt] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, k; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">char</span> opt;</span><br><span class="line">    cin &gt;&gt; opt;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">      q[i] = (Opt)&#123;x, y, k, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;k);</span><br><span class="line">      b[++Cnt] = k;</span><br><span class="line">      q[i] = (Opt)&#123;x, <span class="number">-1</span>, k, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(b + <span class="number">1</span>, b + Cnt + <span class="number">1</span>);</span><br><span class="line">  Cnt = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + Cnt + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">pre</span>(i, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, k; i &lt;= m; ++i) &#123;</span><br><span class="line">    l = q[i].l, r = q[i].r, k = q[i].k;</span><br><span class="line">    <span class="keyword">if</span> (q[i].b) &#123;</span><br><span class="line">      <span class="keyword">int</span> ans = b[<span class="built_in">Pre</span>(l, r, k)];</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">pre</span>(l, <span class="number">-1</span>);</span><br><span class="line">      a[l] = k;</span><br><span class="line">      <span class="built_in">pre</span>(l, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="updated-2021-10-14"><a href="#updated-2021-10-14" class="headerlink" title="updated: 2021-10-14"></a>updated: 2021-10-14</h1><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p>时间复杂度：$O(nlogn)$</p>
<p>扫描线算法是用来求解平面矩形面积和周长问题的一种算法。经常用线段树来维护。最常用的一种算法就是求矩形的面积并。</p>
<p>具体实现：</p>
<p>先上一张图：</p>
<p><img src="/Blog/imgs/post_imgs/Scanline.png" alt=""></p>
<p>对于这张图当中的两个矩形，可以把他<strong>拆成两条线段</strong>分别是左边界和右边界，将左边界上每个点的权值赋为 1，将右边界上每个点的权值赋为 -1。</p>
<p>然后想象一条竖线从左向右扫描。这条竖线用一颗线段树来维护，即线段数上的每个点对应 $x = a$ 上的每个点。因为值域上最多有 $2 \times n$ 种取值，所以可以通过<strong>离散化</strong>使值域降低到可接受范围。</p>
<p>线段树需要维护的有两种信息，一个是当前<strong>线段整体被覆盖的次数</strong>，另一个是<strong>当前线段被覆盖的长度</strong>，用于更新答案。显然，如果 $\text{被覆盖的次数} \ge 1$ 那么被覆盖的长度一定为当前线段的总长度，否则被覆盖的长度就是两个子线段被覆盖的和。</p>
<p>然后每次更新答案只需要 $ans += len(root) \times (x_{now}-x_{lst})$ 。</p>
<p><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线段树，可持久化权值线段树，树套树 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> X[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Scanl</span> &#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> l, r, h;</span><br><span class="line">  <span class="keyword">int</span> mark;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Scanl&amp; y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &lt; y.h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; line[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Segment_tree &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, sum;</span><br><span class="line">  ll len;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) St[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ln(x) St[x].len</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="built_in">s</span>(p) = <span class="built_in">ln</span>(p) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(ls, l, mid);</span><br><span class="line">  <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">s</span>(p))</span><br><span class="line">    <span class="built_in">ln</span>(p) = X[<span class="built_in">r</span>(p) + <span class="number">1</span>] - X[<span class="built_in">l</span>(p)];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">ln</span>(p) = <span class="built_in">ln</span>(ls) + <span class="built_in">ln</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, ll l, ll r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">s</span>(p) += c, <span class="built_in">up</span>(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid)</span><br><span class="line">    <span class="built_in">change</span>(ls, l, r, c);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid)</span><br><span class="line">    <span class="built_in">change</span>(rs, l, r, c);</span><br><span class="line">  <span class="built_in">up</span>(p);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Segment_tree</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Segment_tree;</span><br><span class="line"></span><br><span class="line">unordered_map&lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; pos;  <span class="comment">// 用来离散化映射</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">    X[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = x1, X[i &lt;&lt; <span class="number">1</span>] = x2;</span><br><span class="line">    line[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = (Scanl)&#123;x1, x2, y1, <span class="number">1</span>&#125;;</span><br><span class="line">    line[i &lt;&lt; <span class="number">1</span>] = (Scanl)&#123;x1, x2, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">sort</span>(line + <span class="number">1</span>, line + n + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">sort</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> tot = <span class="built_in">unique</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>) - X - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, tot - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) pos[X[i]] = i;</span><br><span class="line">  ll ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>, pos[line[i].l], pos[line[i].r] - <span class="number">1</span>, line[i].mark);</span><br><span class="line">    ans += <span class="built_in">ln</span>(<span class="number">1</span>) * (line[i + <span class="number">1</span>].h - line[i].h);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Data-Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法 学习笔记</title>
    <url>/Home/Shortest-Path/</url>
    <content><![CDATA[<h1 id="最短路算法-学习笔记"><a href="#最短路算法-学习笔记" class="headerlink" title="最短路算法 学习笔记"></a>最短路算法 学习笔记</h1><p>最短路算法分为多源最短路和单源最短路，比较常见的共有3种最短路算法，分别是 $Floyed$ , $dijkstra$ 和 $SPAF$ 。</p>
<span id="more"></span>
<h2 id="Floyed"><a href="#Floyed" class="headerlink" title="Floyed"></a>Floyed</h2><p>时间复杂度 $O(N^{3})$</p>
<p>多源最短路算法，本质上是动态规划，由于时间复杂度较高应用并不广泛。</p>
<p>代码实现由三层 for 循环组成，最外层枚举状态转移的点，内层枚举起点和终点。</p>
<script type="math/tex; mode=display">f_{k,i,j}=min(f_{k-1,i,k}+f_{k-1,k,j},f_{k-1,i,j}) (i,j,k\in [1,n])</script><p>由于状态转移时只需要上一层的状态，所以可以压缩掉一维，变成:</p>
<script type="math/tex; mode=display">f_{i,j}=min(f_{i,k}+f_{k,j},f_{i,j})(i,j,k\in [1,n])</script><p>完整的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最短路算法 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1e3</span> + <span class="number">10</span>][<span class="number">1e3</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="$Dijkstra$"></a>$Dijkstra$</h2><p>时间复杂度 $O(mlogn)$</p>
<p>单源最短路算法，本质上是广搜变形，即通过贪心思想和优先队列优化的广度优先搜索算法。</p>
<p>具体实现</p>
<ol>
<li>初始化 $dis$ 数组为极大，将起点插入队列，标记起点已访问；</li>
<li>选择当前已入队节点中 $dis$ 最小的点，标记已访问；</li>
<li>松弛操作，更新其他节点，并将未入过队的节点加入队列。</li>
</ol>
<p>证明：</p>
<ol>
<li>选择当前 $dis$ 最小的点来更新其他节点一定最优：<br>通过反证法可以证得。</li>
<li>在没有负环的图中，入过队的节点一定不会再次入队：<br>由证明1可知，后更新的点一定不如先更新的点优，所以任意一点都不会被用它更新过的点更新。</li>
</ol>
<p>因此 $dijkstra$ 算法是正确的。</p>
<p>在最短路算法中相对优秀，稠密图上应用较广。缺点是无法处理有负环的情况。</p>
<p>完整的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最短路算法 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1e5</span> + <span class="number">10</span>], vis[<span class="number">1e5</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, d;  <span class="comment">//为优先队列优化最短路做准备，也可以使用 STL pair</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d &gt; y.d;  <span class="comment">//因为是大根堆，所以重载 &lt; 时，要建相反的符号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; priority_queue&lt; node &gt; q;  <span class="comment">//建立优先队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  q.<span class="built_in">push</span>((node)&#123;s, <span class="number">0</span>&#125;);  <span class="comment">//初始化 dis 数组并将起点插入队列，开始广搜</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">//取出堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> x = tmp.u;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;                   <span class="comment">//根据贪心思想剔除再次访问的元素</span></span><br><span class="line">    vis[x] = <span class="number">1</span>;                             <span class="comment">//标记元素被访问过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;  <span class="comment">//遍历所有能够到达的点</span></span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].t) &#123;  <span class="comment">//松弛操作</span></span><br><span class="line">        dis[y] = dis[x] + e[i].t;</span><br><span class="line">        q.<span class="built_in">push</span>((node)&#123;y, dis[y]&#125;);  <span class="comment">//入队</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SPAF"><a href="#SPAF" class="headerlink" title="SPAF"></a>SPAF</h2><p>关于 $SPAF$ ，它死了…  时间复杂度 $O(nm)$</p>
<p>另一种常用的单源最短路算法，本质上也是广搜变形，通过队列优化的广度优先搜索算法。但 $SPAF$ 并不满足广度优先搜索算法的两段性和单调性。</p>
<p>适合在稀疏图上使用，可以判断是否存在负环，经常与其他图论算法综合使用。</p>
<p>完整的代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最短路算法 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1e5</span> + <span class="number">10</span>], vis[<span class="number">1e5</span> + <span class="number">10</span>];  <span class="comment">//注意这里的 vis 与 dijkstra 不同，记录的是是否在队列中</span></span><br><span class="line"></span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPAF</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  vis[s] = <span class="number">1</span>;  <span class="comment">//标记起点已入队</span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].t) &#123;</span><br><span class="line">        dis[y] = dis[x] + e[i].t;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123;  <span class="comment">//这里入队操作与 dijkstra 不同</span></span><br><span class="line">          q.<span class="built_in">push</span>(y);</span><br><span class="line">          vis[y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Problems"><a href="#Problems" class="headerlink" title="Problems:"></a>Problems:</h1><ul>
<li><a href="https://cloudyskyet.github.io/Blog/cf507e/">CF507E Breaking Good</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/cf543b/">CF543B Destroying Roads</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/cf545e/">CF545E Paths and Trees</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/cf666b/">CF666B World Tour</a></li>
<li><a href="https://cloudyskyet.github.io/Blog/cf715b/">CF715B Complete The Graph</a></li>
<li><a href="">P1073 [NOIP2009 提高组] 最优贸易</a></li>
<li><a href="">P4568 [JLOI2011]飞行路线</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串基础 学习笔记</title>
    <url>/Home/String/</url>
    <content><![CDATA[<h1 id="字符串基础-学习笔记"><a href="#字符串基础-学习笔记" class="headerlink" title="字符串基础 学习笔记"></a>字符串基础 学习笔记</h1><h2 id="字符串-Hash"><a href="#字符串-Hash" class="headerlink" title="字符串 $Hash$"></a>字符串 $Hash$</h2><p>Hash 是一种将一个字符串映射为一个数字的算法,它可以帮助我们在 $O(1)$ 的时间内判断两个字符串是否相等,或进行回文判断。但 $Hash$ 也有一定的出错概率。当数据范围为 $10^5$ 级别时可能会出现哈希冲突，可以使用双模数哈希。</p>
<span id="more"></span>
<h3 id="基础-hash"><a href="#基础-hash" class="headerlink" title="基础 $hash$"></a>基础 $hash$</h3><p>时间复杂度:$O(1)$</p>
<p>对于一个长度为 $n$ 的字符串,它的哈希值为 $\sum_{i=1}^{i\le n} s_i\times base^{n-i} \bmod P$ 。其中 $base$ 和 $P$ 自选。</p>
<p>具体实现：</p>
<ul>
<li>对于一个字符串 $S$ ,它的每一个位前缀哈希值就等于上一位前缀哈希值 $H_{i-1}\times base +s_i$。</li>
<li>预处理出 $base$ 的 $1\sim n$ 次方 $Pow_{1\sim n}$</li>
<li>对于一段区间 $[l,r]$ ,它的 $hash$ 值即为 $H_r-H_{l-1}\times Pow_{r-l+1}$</li>
</ul>
<p>代码实现:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串基础 学习笔记</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> h[<span class="number">1e5</span> + <span class="number">10</span>], pow[<span class="number">1e5</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  <span class="comment">//查询区间Hash值</span></span><br><span class="line">  <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * pow[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_hash</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;  <span class="comment">//初始Hash映射数组</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * base + s[i];  <span class="comment">//套公式</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_pow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  pow[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    pow[i] = pow[i - <span class="number">1</span>] * base;  <span class="comment">//初始 base 幂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="允许失配-k-次的匹配"><a href="#允许失配-k-次的匹配" class="headerlink" title="允许失配 k 次的匹配"></a>允许失配 k 次的匹配</h3><p>时间复杂度:$O(nklogn)$</p>
<p>具体实现:<br>枚举子串,每次二分+hash 找到第一个不同的位置,从这个位置之后继续匹配。</p>
<p>代码实现：暂无</p>
<h2 id="KMP-模式串匹配"><a href="#KMP-模式串匹配" class="headerlink" title="$KMP$ 模式串匹配"></a>$KMP$ 模式串匹配</h2><p>时间复杂度：$O(n)$</p>
<p>$KMP$ 算法是一个在线性时间内完成字符串匹配的算法。</p>
<p>具体实现：</p>
<ul>
<li>$nxt$ 数组维护在文本串每一位最长的前缀等于后缀的长度</li>
<li>当 $nxt$ 数组维护到第 $i$ 位时，<br>如果 $s_{nxt_i+1}=s_{i+1}$ 就把 $nxt$ 数组 $+1$，<br>否则让 $nxt$ 数组 跳 $nxt$。</li>
<li>匹配时直接暴力拓展,失配时跳 $nxt$ 而不是从头开始。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串基础 学习笔记</span></span><br><span class="line"><span class="comment">//s 是文本串,s1 是模式串,Ans 记录匹配成功的次数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i])  <span class="comment">//如果第 i 位失配了,就跳 nxt</span></span><br><span class="line">      j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++j;  <span class="comment">//可以匹配成功就 +1</span></span><br><span class="line">    nxt[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt; <span class="keyword">int</span> &gt; Ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* s1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s1[i])  <span class="comment">//失配就跳 nxt</span></span><br><span class="line">      j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s1[i]) ++j;  <span class="comment">//可以匹配就暴力拓展</span></span><br><span class="line">    <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">      Ans.<span class="built_in">push_back</span>(i - m + <span class="number">1</span>);  <span class="comment">//匹配成功就计入答案</span></span><br><span class="line">      j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher-回文匹配"><a href="#Manacher-回文匹配" class="headerlink" title="$Manacher$ 回文匹配"></a>$Manacher$ 回文匹配</h2><p>时间复杂度：$O(n)$</p>
<p>$Manacher$ 是通过维护 $R$ 和 $mid$ 在线性时间内求一个模式串最长回文子串的算法，但它有一个明显的缺点就是只能判断长度为奇数的回文串，所以要在读入时进行特殊字符补位操作。</p>
<p>证明:</p>
<p>由于 R 是单调递增的，所以时间复杂度也是线性的。</p>
<p>具体实现：</p>
<ul>
<li>在读入时先将第一位设为 ‘@’ 防止数组越界，后将读入字符和补 ‘#’ 交替进行，方便判偶数长度。</li>
<li>每到一位都要维护两个信息以便下次拓展，分别是这一位及以前所有回文子串右端点最大值 $R$ 和拓展 $R$ 到当前值的 $mid$。</li>
<li>更新第 i 位时先继承回文半径为 $i$ 关于 $mid$ 的 对称点 $j$ 的答案和 $i$ 到 $R$ 的距离中的最小值，后暴力拓展，同时更新 $R$ 和 $mid$。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串基础 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scan</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>, s[<span class="number">0</span>] = <span class="string">&#x27;~&#x27;</span>, s[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>, <span class="keyword">int</span> cnt = <span class="number">1</span>;  <span class="comment">//先补特殊字符防止越界</span></span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;a&#x27;</span> || c &gt; <span class="string">&#x27;z&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">    s[++cnt] = c, s[++cnt] = <span class="string">&#x27;#&#x27;</span>, c = <span class="built_in">getchar</span>();  <span class="comment">//补位和读入交替进行</span></span><br><span class="line">  <span class="keyword">return</span> cnt;                                     <span class="comment">//返回字符串长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> R = <span class="number">0</span>, pos, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= R) r[i] = <span class="built_in">min</span>(r[(pos &lt;&lt; <span class="number">1</span>) - i], R - i + <span class="number">1</span>);  <span class="comment">//先继承</span></span><br><span class="line">    <span class="keyword">while</span> (s[i - r[i]] == s[i + r[i]]) r[i]++;             <span class="comment">//后暴力拓展</span></span><br><span class="line">    <span class="keyword">if</span> (i + r[i] &gt; R) R = i + r[i] - <span class="number">1</span>, pos = i;           <span class="comment">//能更新就更新</span></span><br><span class="line">    <span class="keyword">if</span> (r[i] &gt; ans) ans = r[i];                            <span class="comment">///更新答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串-trie"><a href="#字符串-trie" class="headerlink" title="字符串 $trie$"></a>字符串 $trie$</h2><p><a href="https://cloudyskyet.github.io/Blog/Tree-Trie">详见</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan算法 学习笔记</title>
    <url>/Home/Tarjan/</url>
    <content><![CDATA[<h1 id="Tarjan-算法-学习笔记"><a href="#Tarjan-算法-学习笔记" class="headerlink" title="Tarjan 算法 学习笔记"></a>Tarjan 算法 学习笔记</h1><span id="more"></span>
<h2 id="有向图强联通分量"><a href="#有向图强联通分量" class="headerlink" title="有向图强联通分量"></a>有向图强联通分量</h2><p>有向图强联通分量是指，对于 G 的子图 G’ 中，任意两个点都能互达，则G’为G中的强联通分量。</p>
<p>即： $\forall (u,v)\in G’,u-&gt;v\text{且}v-&gt;u$</p>
<h2 id="无向图割点、割边"><a href="#无向图割点、割边" class="headerlink" title="无向图割点、割边"></a>无向图割点、割边</h2><p>无向图的割点是指删去后能使无向图中连通块个数增加的点；割边是指删去后能使无向图连通块增加的边。</p>
<p>割点的等价描述：</p>
<ul>
<li>$\exists u,w\not= v$，$P_{u,w}$ 都经过 v。</li>
<li>V-v 可划分为两个节点集 U,W，$\forall u\in U ,w\in W$ ,$P_{u,w}$ 都经过 v。</li>
</ul>
<p>割边的等价描述：</p>
<ul>
<li>$e\notin \text{G 中的任何回路}$</li>
<li>$\exists u,v\in G,e\in\{P_{u,v}\}$</li>
<li>G-e 可划分为两个节点集 U,W，$\forall u\in U ,w\in W$ ,$e\in\{P_{u,w}\}$。</li>
</ul>
<h2 id="tarjan-算法"><a href="#tarjan-算法" class="headerlink" title="tarjan 算法"></a>tarjan 算法</h2><p>时间复杂度 $O(n+m)$</p>
<p>tarjan 算法是求有向图强联通分量和无向图割点割边的非常实用的算法，本质上是 $DFS$。</p>
<p>具体实现：</p>
<p>在一个有向图中进行 $dfs$ 会出现以下 4 种边：</p>
<ol>
<li>树边，当它指向的节点未被访问过时，会沿着这条边访问指向的节点，所以这条边会被加进搜索树里。</li>
<li>返祖边，当它指向的节点比当前节点深度小时，这条边被称为返祖边。</li>
<li>子向边，指向深度大于当前节点且已被访问过的点。</li>
<li>横插边，指向祖先节点的另一颗子树的边。</li>
</ol>
<p>很容易发现，只有返祖边会产生强连通分量，所以只有 $1, 2$ 边是有用的，$tarjan$ 要做的就是找到这两种边，并统计强连通分量和进行缩点。</p>
<p>$tarjan$ 算法有两个重要的数组，分别是 $dfn$ （深搜时间戳）数组和 $low$ （非搜索树边能到达的深度最小祖先）数组，用来统计强连通分量，以及一个栈 $stc$ 数组，用来缩点。</p>
<p>钦定 $1$ 个节点也算一个强连通分量，这样所有的点必定属于一个强连通分量。可以发现的是，如果当前节点的 $dfn = low$ 说明这个节点是当前连通块中深度最小的，由于每个连通块有且仅有一个这种点，所以可以把当前块内信息统计在这种点上。</p>
<p>有向图缩点要在访问完当前节点在搜索树上所有子节点后在弹栈缩点。而无向图中，由于一个节点可以属于多个双连通分量，所以要在每次访问完一个子节点后都尝试缩点。</p>
<p>代码实现：（有向图）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[Maxn];</span><br><span class="line"><span class="keyword">int</span> dfn[Maxn], low[Maxn], tim, col[Maxn], vis[Maxn];</span><br><span class="line"><span class="keyword">int</span> stc[Maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 接下来三步一定要一气呵成，不然很容易挂。</span></span><br><span class="line">  stc[++top] = x,                         <span class="comment">// 节点入栈</span></span><br><span class="line">    dfn[x] = low[x] = ++tim,              <span class="comment">// 标记时间戳</span></span><br><span class="line">    vis[x] = <span class="number">1</span>;                           <span class="comment">// 标记已访问</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[y]) <span class="built_in">dfs</span> (y),                 <span class="comment">// 如果没访问过，代表这条边是树边，深搜</span></span><br><span class="line">      low[x] = <span class="built_in">min</span> (low[x], low[y]);      <span class="comment">// 用low[y]来更新low[x]</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vis[y])                      <span class="comment">// 说明这条边是返祖边或子向边（横插边所指向的点 vis 均已成 0）</span></span><br><span class="line">      low[x] = <span class="built_in">min</span> (low[x], dfn[y]);      <span class="comment">// 用dfn[v]来更新low[u]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">while</span> ((y = stc[top--]) != <span class="number">0</span>) &#123;       <span class="comment">// 如果当前节点是当前连通块中深度最小的点,就更新答案</span></span><br><span class="line">      vis[y] = <span class="number">0</span>, col[y] = x;             <span class="comment">// 缩点</span></span><br><span class="line">      <span class="keyword">if</span> (y == x) <span class="keyword">break</span>;</span><br><span class="line">      a[x] = <span class="built_in">min</span> (a[x], a[y]);            <span class="comment">// 更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序 学习笔记</title>
    <url>/Home/Topo/</url>
    <content><![CDATA[<h1 id="拓扑排序-学习笔记"><a href="#拓扑排序-学习笔记" class="headerlink" title="拓扑排序 学习笔记"></a>拓扑排序 学习笔记</h1><p>时间复杂度:$O(n+m)$</p>
<p>拓扑排序是对有向无环图节点排序的一种方法，一般通过广度优先搜索实现。可以方便我们实现在 DAG 上 DP 的转移，满足 DP 的无后效性。</p>
<span id="more"></span>
<p>具体实现：</p>
<ol>
<li>在建图的同时统计每个点的入度。扫一遍所有节点，将入度为零的节点入队。</li>
<li>每次从队列中还未被访问的节点取出，从图中删除，即将它能到的节点入度 -1。</li>
<li>将入度被减为 0 的节点入队。</li>
<li>最终队列里的节点顺序即为此 DAG 的拓扑排序。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓扑排序 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//扫描每个节点，寻找入度为0的点入队</span></span><br><span class="line">    <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">//从队列中取出未访问的点，如果需要可以再建一个数组存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">      in[v]--;  <span class="comment">//从图中删除这个节点</span></span><br><span class="line">      <span class="keyword">if</span> (!in[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>字典树 学习笔记</title>
    <url>/Home/Tree-Trie/</url>
    <content><![CDATA[<h1 id="字典树-学习笔记"><a href="#字典树-学习笔记" class="headerlink" title="字典树 学习笔记"></a>字典树 学习笔记</h1><p>字典树是 OI 中常用的数据结构，实现起来较为简单且常数较小，具有较高拓展性，目前应用比较广泛的是 字符串 trie 树，AC自动机，01trie ，和可持久化 01trie,甚至可以实现平衡树的功能。</p>
<span id="more"></span>
<h2 id="字符串-trie"><a href="#字符串-trie" class="headerlink" title="字符串 trie"></a>字符串 trie</h2><p>时间复杂度: $O(nk+m)$ (k为模式串个数,n为模式串长度,m为文本串长度)</p>
<p>能方便地判定一个模式串是否为一些文本串的前缀子串。</p>
<p>具体实现：</p>
<ul>
<li>读入文本串时，对于任意一个文本串，将每个字符作为边，并在路径末端节点权值 +1。</li>
<li>每跳一个字符，如果当前节点已经存在就直接跳，否则新建一个节点。</li>
<li>匹配时，如果跳到某个节点不存在，直接 <code>return false</code> ，如果跳完所有的边还在树上，就 <code>return true</code></li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="keyword">int</span> trie[<span class="number">1e5</span> + <span class="number">10</span>][<span class="number">26</span>], v[<span class="number">1e5</span> + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="comment">//trie 数组记录边的信息,v记录点的信息,cnt 为总结点数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">0</span>, n = <span class="built_in">strlen</span>(str);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> ch = str[k] - <span class="string">&#x27;a&#x27;</span>;  <span class="comment">//将字符转为int</span></span><br><span class="line">    <span class="keyword">if</span> (!trie[p][ch])</span><br><span class="line">      trie[p][ch] = ++cnt;  <span class="comment">//如果没有就新建节点</span></span><br><span class="line">    p = trie[p][ch];        <span class="comment">//直接跳</span></span><br><span class="line">  &#125;</span><br><span class="line">  v[p]++;  <span class="comment">//标记跳到这里有一个字符串结束了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str), p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">    p = trie[p][str[k] - <span class="string">&#x27;a&#x27;</span>];  <span class="comment">//直接跳</span></span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//节点不存在</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//已经跳完所有边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="$AC$ 自动机"></a>$AC$ 自动机</h2><p>时间复杂度: $O(n+m)$</p>
<p>$AC$ 自动机,又称 $trie$ 图,是以 $trie$ 树为基础,结合 $KMP$ 思想,通过维护 $fail$ 指针来多串同时匹配的算法。$fail$ 指针的意义与 $KMP$ 算法中 $nxt$ 数组类似。</p>
<p>具体实现：</p>
<ul>
<li>构建字典树如上，在 $trie$ 树构建好后，广搜构建 $fail$ 指针。</li>
<li>如果当前节点的某个子节点存在，就让它继承 $fail$ 指针，否则将它指向 $fail$ 指针。</li>
<li>匹配时不断地跳 $fail$ 将没有统计过的节点权值计入答案。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trie[<span class="number">0</span>][i]) &#123;</span><br><span class="line">      fail[trie[<span class="number">0</span>][i]] = <span class="number">0</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(trie[<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = trie[x][i];</span><br><span class="line">      <span class="keyword">if</span> (y) &#123;</span><br><span class="line">        fail[y] = trie[fail[x]][i];  <span class="comment">//有子节点就继承fail指针</span></span><br><span class="line">        q.<span class="built_in">push</span>(y);</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        trie[x][i] = trie[fail[x]][i];  <span class="comment">//否则将它指向 fail 指针</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str), p = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; ++k) &#123;</span><br><span class="line">    <span class="keyword">int</span> ch = str[k] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    p = trie[p][ch];                                 <span class="comment">//如果有就跳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &amp;&amp; v[i] != <span class="number">-1</span>; i = fail[i]) &#123;  <span class="comment">//统计答案</span></span><br><span class="line">      ans += v[i];</span><br><span class="line">      v[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="01trie"><a href="#01trie" class="headerlink" title="01trie"></a>01trie</h2><p>时间复杂度:$O(nlogn)$</p>
<p>01 trie 是将数字按照二进制表示存入字典树的数据结构，经常被用来解决最大异或和问题。</p>
<p>具体实现：</p>
<ul>
<li>将所有数按照二进制存入 trie 树，长度不够的在高位补 0，保证树的深度一致。</li>
<li>每跳到一个节点就将当前节点的权值 +1,表示沿着当前节点往下走存在多少个数。</li>
<li>查询两个数的最大异或和时，能向不同的方向走，就向不同的方向走，不能就向同一方向走，边跳边记录数字，最终这两个数即为这个序列中异或和最大的两个数。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>); k; k &gt;&gt;= <span class="number">1</span>) &#123;  <span class="comment">//最高位补齐</span></span><br><span class="line">    c = val &amp; k;</span><br><span class="line">    <span class="keyword">if</span> (!trie[x][c]) &#123;  <span class="comment">//如果没有就新建节点</span></span><br><span class="line">      trie[x][c] = ++tot;</span><br><span class="line">    &#125;</span><br><span class="line">    x = trie[x][c];  <span class="comment">//跳到子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">bool</span> c;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>); k; k &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    c = val &amp; k;</span><br><span class="line">    <span class="keyword">if</span> (trie[x][!c]) &#123;</span><br><span class="line">      <span class="comment">//如果存在相反的方向就向相反的方向跳,同时计入答案</span></span><br><span class="line">      ans += k;</span><br><span class="line">      x = trie[x][!c];  <span class="comment">//这里直接就入了异或和</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      x = trie[x][c];  <span class="comment">//否则就向相同的方向跳</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可持久化-01-trie"><a href="#可持久化-01-trie" class="headerlink" title="可持久化 01 trie"></a>可持久化 01 trie</h2><p>时间复杂度：$O(nlogn)$</p>
<p>可持久化 01trie 与非可持久化 01trie 功能类似，支持静态区间查询。</p>
<p>具体实现与线段树类似。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="comment">//v数组记录的是当前这位及以上数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> lst, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    v[p] = v[lst] + <span class="number">1</span>;  <span class="comment">//先继承</span></span><br><span class="line">    <span class="keyword">if</span> ((val &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!trie[p][<span class="number">0</span>]) trie[p][<span class="number">0</span>] = ++tot;  <span class="comment">//后修改</span></span><br><span class="line">      trie[p][<span class="number">1</span>] = trie[lst][<span class="number">1</span>];</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">      lst = trie[lst][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!trie[p][<span class="number">1</span>]) trie[p][<span class="number">1</span>] = ++tot;</span><br><span class="line">      trie[p][<span class="number">0</span>] = trie[lst][<span class="number">0</span>];</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">      lst = trie[lst][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v[p] = v[lst] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">28</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">bool</span> t = (val &amp; (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">    <span class="keyword">if</span> (v[trie[p1][!t]] - v[trie[p2][!t]]) &#123;  <span class="comment">//能向相反方向跳,就向相反方向跳。</span></span><br><span class="line">      ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      p1 = trie[p1][!t], p2 = trie[p2][!t];</span><br><span class="line">    &#125; <span class="keyword">else</span>  <span class="comment">//否则向相同方向跳</span></span><br><span class="line">      p1 = trie[p1][t], p2 = trie[p2][t];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="trie-树实现平衡树功能"><a href="#trie-树实现平衡树功能" class="headerlink" title="trie 树实现平衡树功能"></a>trie 树实现平衡树功能</h2><p>时间复杂度：$O(nlogn)$</p>
<p>根据之前的内容，不难发现，trie 树可以实现在 log 时间内找到序列中比某个数小的数的个数，且支持 log 时间内修改操作，于是我们就可以借助 trie 树实现平衡树的功能。</p>
<p>Tire 树实现平衡树优点是常数较小，代码较好实现；缺点是对空间要求较大，容易被卡空间。</p>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>具体实现：同 01trie 插入操作。</p>
<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p>具体实现：可以转为删除后插入操作。</p>
<p>1.2代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = Maxk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = (val &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!trie[p][c])</span><br><span class="line">      trie[p][c] = ++cnt;</span><br><span class="line">    p = trie[p][c];</span><br><span class="line">    v[p] += k;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询排名操作"><a href="#查询排名操作" class="headerlink" title="查询排名操作"></a>查询排名操作</h3><p>具体实现：一位一位的匹配，如果当前位为 0 直接向左跳，否则将左半边计入答案，向右跳。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_nlt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = Maxk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      ans += v[trie[p][<span class="number">0</span>]];</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接查到的是比 x 小的数的个数,排名要 +1</span></span><br></pre></td></tr></table></figure>
<h3 id="根据排名查询数值操作"><a href="#根据排名查询数值操作" class="headerlink" title="根据排名查询数值操作"></a>根据排名查询数值操作</h3><p>具体实现：类似线段树二分，如果左边个数小于 k 直接向左跳，否则 查询右半边 排名为 k-左半边个数 的数。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_kth</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = Maxk - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v[trie[p][<span class="number">0</span>]] &gt;= k)</span><br><span class="line">      p = trie[p][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">      k -= v[trie[p][<span class="number">0</span>]];</span><br><span class="line">      p = trie[p][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前驱后继操作"><a href="#前驱后继操作" class="headerlink" title="前驱后继操作"></a>前驱后继操作</h3><p>具体实现：可以转换为 3.4 操作的组合。</p>
<p>5.6代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字典树 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">check_kth</span>(<span class="built_in">check_nlt</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nxt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans;</span><br><span class="line">  ans = <span class="built_in">check_kth</span>(<span class="built_in">check_nlt</span>(x + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Data-Structure</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>CF507E Breaking Good</title>
    <url>/Home/cf507e/</url>
    <content><![CDATA[<h1 id="CF507E-Breaking-Good"><a href="#CF507E-Breaking-Good" class="headerlink" title="CF507E Breaking Good"></a><a href="https://www.luogu.com.cn/problem/CF507E">CF507E Breaking Good</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张无向图，其中一些道路目前可以通行，另一些不能通行，找到从 $1$ 到 $n$ 的最短路，将最短路上不能通行的道路修复，不在最短路上且可以通行的道路删除，问最小改动数，和需要修改的边改后的状态</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>最短路 + 记录最短路径 + 暴力枚举</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先由于找最短路时不需要考虑道路能否通行，所以可以直接 $SPAF$ 或 $dijkstra$ 找到最短路，同时用 $pre$ 数组维护最短路，跑完最短路后，标记每条路是否在最短路上。如果在最短路上且无法通行或不在最短路上且可以通行就将答案 $+1$。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cd</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; <span class="number">1</span> ? x + <span class="number">1</span> : x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于我的 cnt 是从 1 开始的,所以要写一个函数来记录它的反向边</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt, t, u;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], t, u&#125;, hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dis[Maxn], chd[Maxn], vis[Maxn];</span><br><span class="line"><span class="keyword">int</span> pre[Maxn], tot;</span><br><span class="line"><span class="comment">//chd 数组代表这条路径上修复多少条道路,作为最短路的第二关键字</span></span><br><span class="line"><span class="comment">//pre 数组来记录最短路径</span></span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPAF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  <span class="built_in">memset</span>(chd, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(chd));</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>), vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>, chd[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v, c = e[i].t ^ <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//当第一关键字相同时,采取第二关键字来比较路径长度。</span></span><br><span class="line">      <span class="keyword">if</span> (dis[y] == dis[x] + <span class="number">1</span> &amp;&amp; chd[y] &gt; chd[x] + c) &#123;</span><br><span class="line">        <span class="comment">//如果当前边在到达 y 点的最短路径上,就用 pre 数组记录。</span></span><br><span class="line">        chd[y] = chd[x] + c;</span><br><span class="line">        pre[y] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[y] &gt; dis[x] + <span class="number">1</span>) &#123;</span><br><span class="line">        dis[y] = dis[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//虽然不是因为第二关键字更新答案,但第二关键字也要更新,否则路径信息可能混乱。</span></span><br><span class="line">        chd[y] = chd[x] + c;</span><br><span class="line">        pre[y] = i;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g1[Maxn &lt;&lt; <span class="number">1</span>], g2[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">//g1 标记在最短路上的边,g2 标记在最短路上且不能通行的边。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, t; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">    <span class="built_in">add</span>(x, y, t), <span class="built_in">add</span>(y, x, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SPAF</span>();</span><br><span class="line">  <span class="keyword">int</span> x = n;</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line">    g1[pre[x]] = g1[<span class="built_in">cd</span>(pre[x])] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!e[pre[x]].t)</span><br><span class="line">      g2[pre[x]] = g2[<span class="built_in">cd</span>(pre[x])] = <span class="literal">true</span>;</span><br><span class="line">    x = e[pre[x]].u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> Ans[Maxn][<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i - <span class="number">1</span> &lt;= cnt; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//不在最短路上且可以通行,要炸毁</span></span><br><span class="line">    <span class="keyword">if</span> ((!g1[i] || !g1[<span class="built_in">cd</span>(i)]) &amp;&amp; e[i].t) &#123;</span><br><span class="line">      Ans[++tot][<span class="number">1</span>] = e[i].u;</span><br><span class="line">      Ans[tot][<span class="number">2</span>] = e[i].v;</span><br><span class="line">      Ans[tot][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//在最短路上且不能通行,要修复</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g2[i] || g2[<span class="built_in">cd</span>(i)]) &#123;</span><br><span class="line">      Ans[++tot][<span class="number">1</span>] = e[i].u;</span><br><span class="line">      Ans[tot][<span class="number">2</span>] = e[i].v;</span><br><span class="line">      Ans[tot][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, Ans[i][<span class="number">1</span>], Ans[i][<span class="number">2</span>], Ans[i][<span class="number">3</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CF543B Destroying Roads</title>
    <url>/Home/cf543b/</url>
    <content><![CDATA[<h1 id="CF543B-Destroying-Roads"><a href="#CF543B-Destroying-Roads" class="headerlink" title="CF543B Destroying Roads"></a><a href="https://www.luogu.com.cn/problem/CF543B">CF543B Destroying Roads</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张无向图，边权均为 $1$，和两个约束条件，$s_1$ 到 $t_1$ 最短路不超过 $l_1$ ，$s_2$ 到 $t_2$ 最短路不超过 $l_2$ 。问最多删除多少条边。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>最短路 + 暴力枚举</p>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路:"></a>题目思路:</h2><p>求出任意两点最短路。枚举 $[(s1-&gt;t1) 和 (s2-&gt;t2)] 或 [(s1-&gt;t1) 和 (t2-&gt;s2)]$ 路径重合部分的端点,使得总路径长合法,求出此时保留的路径长，再与总边数作差求最大炸毁数。同时与答案取 $max$ 。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^2)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s1, t1, s2, t2, l1, l2, Ans = <span class="number">-1</span>, n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt, u;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], u&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[Maxn][Maxn];</span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"><span class="comment">//n 轮 SPAF 求任意两点最短路。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPAF</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  dis[s][s] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dis[s][y] != inf) <span class="keyword">continue</span>;</span><br><span class="line">      dis[s][y] = dis[s][x] + <span class="number">1</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判定 (s1-&gt;t1) 和 (s2-&gt;t2) 重合部分端点为 x,y 是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (dis[s1][x] + dis[x][y] + dis[y][t1] &lt;= l1 &amp;&amp; dis[s2][x] + dis[x][y] + dis[y][t2] &lt;= l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判定 (s1-&gt;t1) 和 (t2-&gt;s2) 重合部分端点为 x,y 是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (dis[s1][x] + dis[x][y] + dis[y][t1] &lt;= l1 &amp;&amp; dis[t2][x] + dis[x][y] + dis[y][s2] &lt;= l2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算以 x,y 为重合部分端点最大销毁数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calm1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m - (dis[s1][x] + dis[s2][x] + dis[x][y] + dis[y][t1] + dis[y][t2]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算以 x,y 为重合部分端点最大销毁数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calm2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m - (dis[s1][x] + dis[t2][x] + dis[x][y] + dis[y][t1] + dis[y][s2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) dis[i][j] = inf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">SPAF</span>(i);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s1, &amp;t1, &amp;l1);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;s2, &amp;t2, &amp;l2);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="comment">//检验状态合法并统计答案</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check1</span>(i, j)) Ans = <span class="built_in">max</span>(Ans, <span class="built_in">calm1</span>(i, j));</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check2</span>(i, j)) Ans = <span class="built_in">max</span>(Ans, <span class="built_in">calm2</span>(i, j));  <span class="comment">//同上</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (dis[s1][t1] &lt;= l1 &amp;&amp; dis[s2][t2] &lt;= l2) &#123;</span><br><span class="line">    <span class="comment">//判断无重合部分是否合法并取 max</span></span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, m - dis[s1][t1] - dis[s2][t2]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CF545E Paths and Trees</title>
    <url>/Home/cf545e/</url>
    <content><![CDATA[<h1 id="CF545E-Paths-and-Trees"><a href="#CF545E-Paths-and-Trees" class="headerlink" title="CF545E Paths and Trees"></a><a href="https://www.luogu.com.cn/problem/CF545E">CF545E Paths and Trees</a></h1><h2 id="题目翻译"><a href="#题目翻译" class="headerlink" title="题目翻译:"></a>题目翻译:</h2><p>给定一张带正权的无向图和一个源点，求边权和最小的最短路径树。</p>
<span id="more"></span>
<h2 id="题目正解"><a href="#题目正解" class="headerlink" title="题目正解:"></a>题目正解:</h2><p>最短路 + 记录最短路径</p>
<h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路:"></a>题目思路:</h2><p>无了</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogn)$</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码:"></a>题目代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有什么可注释的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">  ll t;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll t)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], t&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u;</span><br><span class="line">  ll d;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d &gt; y.d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt; node &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, vis[Maxn], pre[Maxn];</span><br><span class="line">ll dis[Maxn], ans[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>((node)&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> x = tmp.u;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dis[y] &gt; dis[x] + e[i].t) &#123;</span><br><span class="line">        dis[y] = dis[x] + e[i].t;</span><br><span class="line">        pre[y] = i;</span><br><span class="line">        q.<span class="built_in">push</span>((node)&#123;y, dis[y]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (dis[y] == dis[x] + e[i].t &amp;&amp; e[i].t &lt; e[pre[y]].t) &#123;</span><br><span class="line">        pre[y] = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">    <span class="built_in">add</span>(x, y, t), <span class="built_in">add</span>(y, x, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">  <span class="built_in">solve</span>(s);</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s) <span class="keyword">continue</span>;</span><br><span class="line">    sum += e[pre[i]].t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (pre[i] + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CF620E New Year Tree</title>
    <url>/Home/cf620e/</url>
    <content><![CDATA[<h1 id="早期题解"><a href="#早期题解" class="headerlink" title="早期题解"></a>早期题解</h1><span id="more"></span>
<h1 id="CF620E-New-Year-Tree"><a href="#CF620E-New-Year-Tree" class="headerlink" title="CF620E New Year Tree"></a><a href="https://www.luogu.com.cn/problem/CF620E">CF620E New Year Tree</a></h1><h4 id="线段树-dfs序-状态压缩搞定这道题"><a href="#线段树-dfs序-状态压缩搞定这道题" class="headerlink" title="线段树+dfs序+状态压缩搞定这道题"></a>线段树+dfs序+状态压缩搞定这道题</h4><p>我们把每种颜色 $k$ 设为 $2^k$，先dfs一遍把树变成区间，同时维护子树信息。（我用的是 $pair$，当然也可以用两个数组）</p>
<p>同时，这道题的代码<del>比较</del>长，要注意细节呦。（比如说要开 $long long$ ）</p>
<p>具体推导过程楼下已经写得很详细了，我就是来上份详细注释、可读性较高的代码。（那里偷来的自信）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">400010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], cnt;  <span class="comment">//用链式前向星存边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adg</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//加边操作</span></span><br><span class="line">  e[++cnt].v = v, e[cnt].nxt = head[u], head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[Maxn], t;            <span class="comment">//pos用来存放dfs序</span></span><br><span class="line">pair&lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; tim[Maxn];  <span class="comment">//用来维护子树信息 tim[i].second代表这棵子树的最后一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  pos[++t] = x;                             <span class="comment">//存储dfs序</span></span><br><span class="line">  tim[x].first = t;                         <span class="comment">//这棵子树的根</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;  <span class="comment">//遍历这个节点的边</span></span><br><span class="line">    <span class="keyword">int</span> tmp = e[i].v;                       <span class="comment">//存放下个节点</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == f) <span class="keyword">continue</span>;                 <span class="comment">//不能往回走</span></span><br><span class="line">    <span class="built_in">dfs</span>(tmp, x);</span><br><span class="line">  &#125;</span><br><span class="line">  tim[x].second = t;  <span class="comment">//这棵子树的最后一个元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1      <span class="comment">//偷个懒，事先设定好</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1  <span class="comment">//和p*2+1一样</span></span></span><br><span class="line">ull c[Maxn];           <span class="comment">//原序列</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  ull dat, chg;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l  <span class="comment">//同样，方便写代码，也方便理解（从哪里偷来的自信）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d(x) St[x].dat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> c(x) St[x].chg</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">2</span>];  <span class="comment">//因为最后一层有空节点，所以要开四倍</span></span><br><span class="line"><span class="comment">//进入最可爱的线段树部分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  <span class="comment">//建树</span></span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;              <span class="comment">//确定子树范围</span></span><br><span class="line">  <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">    <span class="built_in">d</span>(p) = <span class="number">1ll</span> * c[pos[l]];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;  <span class="comment">//如果区间长度为一，代表到了最底层，返回</span></span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(ls, l, mid);      <span class="comment">//建立左子树</span></span><br><span class="line">  <span class="built_in">build</span>(rs, mid + <span class="number">1</span>, r);  <span class="comment">//建立右子树</span></span><br><span class="line">  <span class="built_in">d</span>(p) = <span class="built_in">d</span>(ls) | <span class="built_in">d</span>(rs);   <span class="comment">//上传信息，由于要统计颜色个数，所以用不进位加法（或|），代表有这种颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;             <span class="comment">//下传标记，注意是直接修改，不是增加。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">c</span>(p)) &#123;                    <span class="comment">//如果有标记</span></span><br><span class="line">    <span class="built_in">d</span>(ls) = <span class="built_in">c</span>(p), <span class="built_in">d</span>(rs) = <span class="built_in">c</span>(p);  <span class="comment">//直接修改子树值</span></span><br><span class="line">    <span class="built_in">c</span>(ls) = <span class="built_in">c</span>(p), <span class="built_in">c</span>(rs) = <span class="built_in">c</span>(p);  <span class="comment">//把标记下传给字数</span></span><br><span class="line">    <span class="built_in">c</span>(p) = <span class="number">0ll</span>;                  <span class="comment">//取消标记</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;  <span class="comment">//区间修改操作</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="built_in">d</span>(p) = d;</span><br><span class="line">    <span class="built_in">c</span>(p) = d;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;           <span class="comment">//如果覆盖区间，直接打标记，降低复杂度</span></span><br><span class="line">  <span class="built_in">spread</span>(p);  <span class="comment">//否则先下传标记</span></span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">change</span>(ls, l, r, d);  <span class="comment">//如果左子树有重叠，修改左子树</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) <span class="built_in">change</span>(rs, l, r, d);   <span class="comment">//同理可证</span></span><br><span class="line">  <span class="built_in">d</span>(p) = <span class="built_in">d</span>(ls) | <span class="built_in">d</span>(rs);               <span class="comment">//上传信息，线段树每部操作都要顺便上传信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;  <span class="comment">//询问操作</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">d</span>(p);</span><br><span class="line">  &#125;           <span class="comment">//如果完全覆盖，就直接返回</span></span><br><span class="line">  <span class="built_in">spread</span>(p);  <span class="comment">//否则先下传标记</span></span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  ull val = <span class="number">0</span>;                         <span class="comment">//一开始没有任何颜色</span></span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) val |= <span class="built_in">ask</span>(ls, l, r);  <span class="comment">//如果左子树有重叠，统计左子树</span></span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) val |= <span class="built_in">ask</span>(rs, l, r);   <span class="comment">//如果右子树有重叠，统计右子树</span></span><br><span class="line">  <span class="built_in">d</span>(p) = <span class="built_in">d</span>(ls) | <span class="built_in">d</span>(rs);                <span class="comment">//顺便上传信息</span></span><br><span class="line">  <span class="keyword">return</span> val;                          <span class="comment">//返回颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;tmp);</span><br><span class="line">    c[i] = (<span class="number">1ll</span> &lt;&lt; tmp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">adg</span>(x, y), <span class="built_in">adg</span>(y, x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) x &amp; -x</span></span><br><span class="line">  <span class="keyword">int</span> t, v, l, r;</span><br><span class="line">  ull ch;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, tmp; k &lt;= m; k++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;v);</span><br><span class="line">      l = tim[v].first, r = tim[v].second;</span><br><span class="line">      ull temp = <span class="built_in">ask</span>(<span class="number">1</span>, l, r);</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; temp; temp -= <span class="built_in">lowbit</span>(temp)) ans++;  <span class="comment">//统计答案，lowbit是最后一位为 1 的数位</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;v, &amp;tmp);</span><br><span class="line">      l = tim[v].first, r = tim[v].second, ch = (<span class="number">1ll</span> &lt;&lt; tmp);</span><br><span class="line">      <span class="built_in">change</span>(<span class="number">1</span>, l, r, ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Summary</tag>
        <tag>EP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF666B World Tour</title>
    <url>/Home/cf666b/</url>
    <content><![CDATA[<h1 id="CF666B-World-Tour"><a href="#CF666B-World-Tour" class="headerlink" title="CF666B World Tour"></a><a href="https://www.luogu.com.cn/problem/CF666B">CF666B World Tour</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>一张 $n$ 个点 $m$ 条边的有向图，每条边的权值相同。你要找 $4$ 个点 $a,b,c,d$ 使得 $(a-&gt;b-&gt;c-&gt;d)$ 的最短路最长 ( a,b,c,d 之间要有路)，输出一组解。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>最短路 + 暴力枚举</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>先 $n$ 轮 $SPAF$ 跑出任意两点最短路,然后处理出 每个点 $i$ 能到的点 $j$ 和能到 $i$ 的点 $j$,把路径从大到小排序,枚举两个点 $b$ 和 $c$ ,从能到 $b$ 的点中前 $3$ 个选出 $a$ ，从 $c$ 能到的点中前 $3$ 个选出 $d$ ,记录当前路径长度,最后选出最优解。（至于为何是前 3 我也不太清楚…）</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^2)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125; e[Maxm];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u]&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, dis[Maxn][Maxn], vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">//n 轮 SPAF 求任意两点最短路径</span></span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  vis[s] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dis[s][y] &gt; dis[s][x] + <span class="number">1</span>) &#123;</span><br><span class="line">        dis[s][y] = dis[s][x] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y]) &#123; q.<span class="built_in">push</span>(y), vis[y] = <span class="number">1</span>; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt; pair&lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; &gt; A[Maxn], B[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span>(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">solve</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> Ans = <span class="number">0</span>, a, b, c, d;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (dis[i][j] != inf)</span><br><span class="line">        A[i].<span class="built_in">push_back</span>(<span class="built_in">mkp</span>(dis[i][j], j));  <span class="comment">//求 i 能到的点</span></span><br><span class="line">      <span class="keyword">if</span> (dis[j][i] != inf)</span><br><span class="line">        B[i].<span class="built_in">push_back</span>(<span class="built_in">mkp</span>(dis[j][i], j));  <span class="comment">//求能到 i 的点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(A[i].<span class="built_in">begin</span>(), A[i].<span class="built_in">end</span>());  <span class="comment">//这里是从小到大排序的,后面要从后往前枚举</span></span><br><span class="line">    <span class="built_in">sort</span>(B[i].<span class="built_in">begin</span>(), B[i].<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ta, tb, tc, td, Sta, Stb, Stc, Std;</span><br><span class="line">  <span class="keyword">for</span> (tb = <span class="number">1</span>; tb &lt;= n; tb++) &#123;  <span class="comment">//枚举 b</span></span><br><span class="line">    Stb = B[tb].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (tc = <span class="number">1</span>; tc &lt;= n; tc++) &#123;          <span class="comment">//枚举 c</span></span><br><span class="line">      <span class="keyword">if</span> (tb == tc || dis[tb][tc] == inf)  <span class="comment">//判定不合法</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      Stc = A[tc].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Sta = Stb - <span class="number">1</span>; Sta &gt;= <span class="number">0</span> &amp;&amp; Sta &gt;= Stb - <span class="number">3</span>; Sta--) &#123;  <span class="comment">//找 a</span></span><br><span class="line">        ta = B[tb][Sta].second;</span><br><span class="line">        <span class="keyword">if</span> (ta == tb || ta == tc || dis[ta][tb] == inf) <span class="keyword">continue</span>;  <span class="comment">//判定不合法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Std = Stc - <span class="number">1</span>; Std &gt;= <span class="number">0</span> &amp;&amp; Std &gt;= Stc - <span class="number">3</span>; Std--) &#123;  <span class="comment">//找 d</span></span><br><span class="line">          td = A[tc][Std].second;</span><br><span class="line">          <span class="keyword">if</span> (td == tb || td == tc || td == ta || dis[tc][td] == inf)  <span class="comment">//判定不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (Ans &lt; dis[ta][tb] + dis[tb][tc] + dis[tc][td]) &#123;  <span class="comment">//更新答案</span></span><br><span class="line">            Ans = dis[ta][tb] + dis[tb][tc] + dis[tc][td];</span><br><span class="line">            a = ta, b = tb, c = tc, d = td;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, c, d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CF715B Complete The Graph</title>
    <url>/Home/cf715b/</url>
    <content><![CDATA[<h1 id="CF715B-Complete-The-Graph"><a href="#CF715B-Complete-The-Graph" class="headerlink" title="CF715B Complete The Graph"></a><a href="https://www.luogu.com.cn/problem/CF715B">CF715B Complete The Graph</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张无向图 ，和一个约束条件：$s$ 到 $t$ 的最短路长度为 $l$。修改所有边权为 0 的边使之权值为 $[1,1e18]$ ,使得约束条件成立。输出 “YES” 后输出每条边权值,如不能则输出 “NO”。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>两遍最短路，一遍统计，一遍修改</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>由于空边的边权至少是 $1$ ，所以输入时直接判断边权，标记后权值赋成 $1$ ，如果一遍最短路后权值大于 $l$ 说明无解。否则再跑一遍最短路，将空边权值赋成合法的最大值，来保证 $(s-&gt;t)$ 最短路等于 $l$, 如果所有可操作边都操作后最短路仍不为 $l$ 则无解。否则输出每条边。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> E[Maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line">ll t1[Maxn &lt;&lt; <span class="number">4</span>], t2[Maxn &lt;&lt; <span class="number">4</span>];</span><br><span class="line"><span class="comment">//由于需要频繁修改边权，所以建立一个映射关系，双向边对应一个权值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt, u;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u], u&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, d;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> d &gt; y.d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt; node &gt; q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dis1[Maxn], dis2[Maxn];</span><br><span class="line"><span class="keyword">int</span> vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;  <span class="comment">//第一遍 dijkstra 求最短路</span></span><br><span class="line">  <span class="built_in">memset</span>(dis1, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis1));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  q.<span class="built_in">push</span>((node)&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">  dis1[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> x = tmp.u;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (dis1[y] &gt; dis1[x] + t1[E[i]]) &#123;</span><br><span class="line">        dis1[y] = dis1[x] + t1[E[i]];</span><br><span class="line">        q.<span class="built_in">push</span>((node)&#123;y, dis1[y]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> nxted)</span> </span>&#123;  <span class="comment">//第二遍 dijkstra 改边权</span></span><br><span class="line">  <span class="built_in">memset</span>(dis2, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis2));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  q.<span class="built_in">push</span>((node)&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">  dis2[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node tmp = q.<span class="built_in">top</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">int</span> x = tmp.u;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">      <span class="keyword">if</span> (!t2[E[i]]                                 <span class="comment">//判断是否为空边</span></span><br><span class="line">          &amp;&amp; dis2[x] + t1[E[i]] &lt; dis1[y] + nxted)  <span class="comment">//判断边权是否需要修改</span></span><br><span class="line">        t1[E[i]] = dis1[y] + nxted - dis2[x];       <span class="comment">//赋成合法最大值</span></span><br><span class="line">      <span class="keyword">if</span> (dis2[y] &gt; dis2[x] + t1[E[i]]) &#123;           <span class="comment">//维护修改后最短路</span></span><br><span class="line">        dis2[y] = dis2[x] + t1[E[i]];</span><br><span class="line">        q.<span class="built_in">push</span>((node)&#123;y, dis2[y]&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">  ll L;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%d%d&quot;</span>, &amp;n, &amp;m, &amp;L, &amp;s, &amp;t);</span><br><span class="line">  s += <span class="number">1</span>, t += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">    <span class="built_in">add</span>(x + <span class="number">1</span>, y + <span class="number">1</span>), <span class="built_in">add</span>(y + <span class="number">1</span>, x + <span class="number">1</span>);</span><br><span class="line">    t1[i] = t2[i] = z;</span><br><span class="line">    <span class="keyword">if</span> (!z) t1[i] = <span class="number">1</span>;</span><br><span class="line">    E[cnt] = E[cnt - <span class="number">1</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve1</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (dis1[t] &gt; L) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">solve2</span>(s, L - dis1[t]);</span><br><span class="line">  <span class="keyword">if</span> (dis2[t] != L) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> u = e[i].u - <span class="number">1</span>, v = e[i].v - <span class="number">1</span>, t = t1[E[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, u, v, t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得算法（exgcd） 学习笔记</title>
    <url>/Home/exgcd-0/</url>
    <content><![CDATA[<h1 id="拓展欧几里得算法（exgcd）-学习笔记"><a href="#拓展欧几里得算法（exgcd）-学习笔记" class="headerlink" title="拓展欧几里得算法（exgcd） 学习笔记"></a>拓展欧几里得算法（exgcd） 学习笔记</h1><p>时间复杂度： $O(logn)$</p>
<p>拓展欧几里得算法是用来解决二元一次不定方程的一种算法，即这个式子：</p>
<p>$ax + by = c$</p>
<p>其中 c 一定要满足 $c | gcd(a,b)$ 。否则无解。</p>
<span id="more"></span>
<p>它实际上是先解出来 $ax + by = gcd(a,b)$ ，然后再将解出来的 x $\times c / gcd(a,b)$ 即可。</p>
<p>具体实现：</p>
<ul>
<li>当 $b = 0$ 时，一组解就是 $\begin{cases}x = 1 \\y = 0\end{cases}$ 。</li>
<li>只要在回溯时倒着推回去便能找到一组特解。</li>
<li>$x_0$ 便是 $x + k \times lcm(a,b)$ 。</li>
</ul>
<p>证明： </p>
<script type="math/tex; mode=display">\because ax + by = gcd(a,b)</script><script type="math/tex; mode=display">\text且 gcd(a,b) = gcd(b,a\mod b)</script><p>将下带入上，并设</p>
<script type="math/tex; mode=display">bx'+(a\mod b)y'=gcd(b,a\mod b)</script><script type="math/tex; mode=display">\text又\because a\mod b=a-\left\lfloor a/b \right\rfloor * b</script><script type="math/tex; mode=display">\therefore bx'+(a-\left\lfloor a/b \right\rfloor * b)y'=gcd(a,b)</script><p>这步很多博客都跳步了，但我认为其实很重要：</p>
<script type="math/tex; mode=display">\therefore ay'+bx'-b\left\lfloor a/b \right\rfloor * y'=gcd(a,b)</script><script type="math/tex; mode=display">\therefore ay'+b(x' - \left\lfloor a/b \right\rfloor * y')=gcd(a,b)</script><script type="math/tex; mode=display">\therefore x = y',y = x' - \left\lfloor a/b \right\rfloor * y'</script><p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓展欧几里得算法（exgcd） 学习笔记</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> tx, ty, g = <span class="built_in">exgcd</span>(b, a % b, tx, ty);</span><br><span class="line">  x = ty, y = tx - a / b * ty;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exgcd 同时也可以用来求乘法逆元，条件是 $x$ 和 $p$ 互质。</p>
<p>原理是：</p>
<p>设 $x$ 在$\mod p$ 意义下的逆元是 $x^{-1}$。</p>
<script type="math/tex; mode=display">\because x * x^{-1} \equiv 1(\mod p)</script><script type="math/tex; mode=display">\therefore x * x^{-1} = k * p + 1</script><script type="math/tex; mode=display">\text即 x * x^{-1} - k * p = 1</script><p>这样就化成了扩展欧几里得的常见形式了，$x$ 和 $p$ 已知，$x^{-1}$ 和 $k$ 是要求的。（但一般 k 求出来没有什么用）</p>
<p><a href="https://www.luogu.com.cn/problem/P1082">P1082 [NOIP2012 提高组] 同余方程</a></p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拓展欧几里得算法（exgcd） 学习笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> tx, ty, g = <span class="built_in">exgcd</span>(b, a % b, tx, ty);</span><br><span class="line">  x = ty, y = tx - a / b * ty;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b, x, k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">  <span class="keyword">int</span> g = <span class="built_in">exgcd</span>(a, b, x, k);</span><br><span class="line">  x = (x % b + b) % b;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客搭建教程</title>
    <url>/Home/hexo/</url>
    <content><![CDATA[<h1 id="Hexo-博客搭建教程"><a href="#Hexo-博客搭建教程" class="headerlink" title="Hexo 博客搭建教程"></a>Hexo 博客搭建教程</h1><p>注：大部分为搬运过来的。仅适用于 Windows。</p>
<span id="more"></span>
<h2 id="1-更便捷的途径"><a href="#1-更便捷的途径" class="headerlink" title="-1. 更便捷的途径"></a>-1. 更便捷的途径</h2><p><a href="https://github.com/renbaoshuo">renbaoshuo</a>/<strong><a href="https://github.com/renbaoshuo/hexo-for-oiers">hexo-for-oiers</a></strong></p>
<p>使用了 OI-wiki 同款主题，github 自动部署</p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>如果你要自己搭博客，不建议<strong>网络直连</strong></p>
<h2 id="1-安装-NodeJS-和-Git"><a href="#1-安装-NodeJS-和-Git" class="headerlink" title="1. 安装 NodeJS 和 Git"></a>1. 安装 NodeJS 和 Git</h2><p>注意文章时间，如果间隔过长建议<a href="https://nodejs.org/en/">NodeJS官网</a>和<a href="https://git-scm.com/">Git</a>挑选。</p>
<p>快捷链接：</p>
<ul>
<li><a href="https://nodejs.org/dist/v16.13.1/node-v16.13.1-x64.msi">NodeJS 16.13.1 LTS 安装包</a>  </li>
<li><a href="https://github.com/git-for-windows/git/releases/download/v2.34.1.windows.1/Git-2.34.1-64-bit.exe">Git v2.34.1 安装包</a>  </li>
</ul>
<h2 id="2-输入指令。"><a href="#2-输入指令。" class="headerlink" title="2. 输入指令。"></a>2. 输入指令。</h2><p>首先新建一个文件夹，然后起好名字。用终端打开。<br>然后输入如下指令：<br><img src="/Blog/imgs/post_imgs/hexo-p1.png" alt=""><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><br>如果你的 hexo 指令报错了，那么你可能需要这样：<br><img src="/Blog/imgs/post_imgs/hexo-p2.png" alt=""><br>把对勾点上然后点应用。如果你是 Windows 10 直接搜索脚本也是可以找到的。<br>然后壳就差不多了。<br>你可以找到博客文件夹，找到<code>_config.yml</code>。<br>根据提示个性化修改里面的内容。（篇末附上我的配置文件）</p>
<h2 id="3-把-hexo-的博客翻译并解释了一下。。"><a href="#3-把-hexo-的博客翻译并解释了一下。。" class="headerlink" title="3. 把 hexo 的博客翻译并解释了一下。。"></a>3. 把 hexo 的博客翻译并解释了一下。。</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="创建一个新的文章"><a href="#创建一个新的文章" class="headerlink" title="创建一个新的文章"></a>创建一个新的文章</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<p>解释：如果你想写一篇名叫 <code>IAKIOI</code> 的博客，那么你可以这样:<br><img src="/Blog/imgs/post_imgs/hexo-p3.png" alt=""></p>
<p>如果你想更改，你大概能在下面的位置找到它：</p>
<p><img src="/Blog/imgs/post_imgs/hexo-p5.png" alt=""></p>
<h4 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<p>解释：如果你想边写博客边预览，那么你就可以这样输入这条指令，然后<strong>保持终端打开</strong>。</p>
<p>然后在浏览器中输入 <code>http://localhost:4000</code> 就可以看了。<br>在更改配置文件或组件后要重新启动，否则不需要，刷新页面即可。<br>补充：</p>
<p>清除缓存，用于在更改一些配置文件或组件后防止引起混乱。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure></p>
<p>如果你的博客刚刚按照上面的步骤搭好，那么他应该是这样的：<br><img src="/Blog/imgs/post_imgs/hexo-p4.png" alt=""></p>
<p>后面这两条待会再说。</p>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h4 id="部署到站点"><a href="#部署到站点" class="headerlink" title="部署到站点"></a>部署到站点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h2 id="4-配主题"><a href="#4-配主题" class="headerlink" title="4. 配主题"></a>4. 配主题</h2><p>这才是自己搭博客的精髓呀！<br>另外有些主题是不支持数学公式的。谨慎选择，这里推荐：<br><a href="https://github.com/next-theme/hexo-theme-next">NexT</a><br><a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a><br><a href="https://github.com/honjun/hexo-theme-sakura">sakura</a><br><a href="https://github.com/Fechin/hexo-theme-diaspora">diaspora</a>（我在用的主题）<br>一般主题间切换有一定成本，不建议从某个主题，除默认，更换到其他主题建议新建文件夹重新来过。。<br>不过如果基建还在，新建文件夹会少很多步骤。这时就要运用人类智慧了。</p>
<h2 id="5-生成并上传至-github-仓库"><a href="#5-生成并上传至-github-仓库" class="headerlink" title="5. 生成并上传至 github 仓库"></a>5. 生成并上传至 github 仓库</h2><h3 id="手把手教你-github。（这里如果之前用过可以选择性跳过）"><a href="#手把手教你-github。（这里如果之前用过可以选择性跳过）" class="headerlink" title="手把手教你 github。（这里如果之前用过可以选择性跳过）"></a>手把手教你 github。（这里如果之前用过可以选择性跳过）</h3><p>首先你登上<a href="https://github.com/">github 官网</a>（前提是你运气够好等得上。。）<br><img src="/Blog/imgs/post_imgs/hexo-p6.png" alt=""><br>然后按照指引注册账号。<br><img src="/Blog/imgs/post_imgs/hexo-p7.png" alt=""><br>点击新建仓库：<br><img src="/Blog/imgs/post_imgs/hexo-p8.png" alt=""><br><img src="/Blog/imgs/post_imgs/hexo-p9.png" alt=""><br>这个仓库名要严格 <code>name.github.io</code> 回方便很多，这里报错是因为我已经有这个仓库了。<br>然后转入输入网址<code>https://github.com/settings/tokens/new</code>，转入个人密钥设置，Note 随意但必填，勾选 repo ：<br><img src="/Blog/imgs/post_imgs/hexo-p10.png" alt=""><br>点新建后<strong>记下来</strong><br>然后 github 方面就完成了。</p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>找到博客文件夹，找到<code>_config.yml</code>。<br>在里面找到<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><br>改成<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&#x27;yourname&#x27;/&#x27;yourname&#x27;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;yourname&#x27;</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">&#x27;youremail&#x27;</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">&#x27;yourtoken&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>加单引号部分为你个人信息。<br>然后终端跳转到文件夹，输入指令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br><img src="/Blog/imgs/post_imgs/hexo-p11.png" alt=""><br>然后你就可以尝试用 <code>hexo g</code> 和 <code>hexo d</code> 或直接 <code>hexo g -d</code>。<br>第一次上传应该会提醒输入密码，这时，要输入密钥，即 token。</p>
<p>应该差不多了吧。。。</p>
<p>附（删减的部分为没有进行更改的部分，并非真正删除）：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Blog</span> <span class="string">of</span> <span class="string">CloudySky</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">永远相信美好的事情即将发生。</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">纵使世界万般残酷，总有温暖值得守护。</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">CloudySky</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://cloudyskyet.github.io/Blog</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;  &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">diaspora</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/CloudySkyET/Blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">CloudySkyET</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">马赛克</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">马赛克</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题要求配置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>P1868 饥饿的奶牛</title>
    <url>/Home/p1868/</url>
    <content><![CDATA[<h1 id="P1868-饥饿的奶牛"><a href="#P1868-饥饿的奶牛" class="headerlink" title="P1868 饥饿的奶牛"></a><a href="https://www.luogu.com.cn/problem/P1868">P1868 饥饿的奶牛</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>共有 n 个区间，选取任意个不重叠的区间使覆盖面积最大，求最大面积。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>DP + 二分</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先考虑给线段排序。因为每回你都要满足左端点大于要转移点的右端点，所以按照右端点排序会方便些，因为这样就可以二分了。</p>
<p>然后考虑转移方程。设 $f_i$ 表示考虑到第 i 片草的最大价值。</p>
<p>可以按照这个草选不选分为两种。</p>
<p>如果不选那么 $f_i = f_{i-1}$</p>
<p>如果选的话因为 f 满足单调性，所以直接二分查找最后一个右端点小于当前草左端点的草，设它为 k。</p>
<p>$f_i = f_k + val_i$</p>
<p>将以上两种情况取 $max$ 即可。</p>
<p>最终转移方程：</p>
<script type="math/tex; mode=display">f_i = max (f_{i-1}, f_k + r_i - l_i + 1)</script><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1.5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">range</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> range y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r &lt; y.r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[Maxn], g[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = R;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid].r &gt;= val) r = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> l = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n; <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].l, &amp;a[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">find</span> (a[i].l , i - <span class="number">1</span>);</span><br><span class="line">    f[i] = <span class="built_in">max</span> (f[i<span class="number">-1</span>], f[k] + a[i].r - a[i].l + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P1972 [SDOI2009]HH的项链</title>
    <url>/Home/p1972/</url>
    <content><![CDATA[<h1 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009]HH的项链"></a><a href="https://www.luogu.com.cn/problem/P1972">P1972 [SDOI2009]HH的项链</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $n$ 的序列 $a_1, a_2, …, a_n$ ，和 $m$ 组询问， 每次给定 $l, r$ ，求区间 $[l, r]$ 中<strong>不同的</strong>数字有几种。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>可持久化线段树     </p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>可持久化线段树不同于主席树的用法。</p>
<p>注意到这道题题目唯一的难点在于不同的数字，所以可以考虑对相同的数字消除贡献。</p>
<p>最简单有效的方法就是只留下每种数字最后出现的位置的贡献， 但同时又要保证上一次的贡献在这一次贡献出现前不被消除。</p>
<p>所以考虑每次更新某个数 $a_i$，如果之前出现过，直接在 $i - 1$ 版本消除贡献，紧跟着将这次的贡献加进来。</p>
<p>这样在每个点构造的线段树都是一个 $a$ 序列<strong>前缀</strong>的，每个数字只会在最后出现的位置被统计到的<strong>独立线段树</strong>。</p>
<p>所以查询答案时，直接在 $R$ 版本的线段树上，查询 $[L, R]$ 区间和即可。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ls, rs, val;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) St[x].ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) St[x].rs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].val</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rt[Maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> np = ++tot; </span><br><span class="line">  St[np] = St[p], <span class="built_in">v</span>(np) += k;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> np;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid) </span><br><span class="line">    <span class="built_in">ls</span>(np) = <span class="built_in">add</span> (<span class="built_in">ls</span>(p), l, mid, v, k);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">rs</span>(np) = <span class="built_in">add</span> (<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v, k);</span><br><span class="line">  <span class="keyword">return</span> np;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span> (<span class="built_in">ls</span>(p), l, mid, v) + <span class="built_in">v</span>(<span class="built_in">rs</span>(p));</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ask</span> (<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, r, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lst[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, tmp, v; i &lt;= n; ++i) &#123;</span><br><span class="line">    v = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="keyword">if</span> (!lst[v])</span><br><span class="line">      rt[i] = <span class="built_in">add</span> (rt[i - <span class="number">1</span>], <span class="number">1</span>, n, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      tmp = <span class="built_in">add</span> (rt[i - <span class="number">1</span>], <span class="number">1</span>, n, lst[v], <span class="number">-1</span>),</span><br><span class="line">      rt[i] = <span class="built_in">add</span> (tmp, <span class="number">1</span>, n, i, <span class="number">1</span>);</span><br><span class="line">    lst[v] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">read</span> (), r = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="built_in">print</span> (<span class="built_in">ask</span> (rt[r], <span class="number">1</span>, n, l));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Data-Structure</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P1967 [NOIP2013 提高组] 货车运输</title>
    <url>/Home/p1967/</url>
    <content><![CDATA[<h1 id="P1967-NOIP2013-提高组-货车运输"><a href="#P1967-NOIP2013-提高组-货车运输" class="headerlink" title="P1967 [NOIP2013 提高组] 货车运输"></a><a href="https://www.luogu.com.cn/problem/P1967">P1967 [NOIP2013 提高组] 货车运输</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张无向图,多组询问,每次查询两个点之间路径上最小边权最大。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>最大生成树 + 倍增Lca 。</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>由于题目只要求最小边权最大，并没有限制路径长度，所以路径必然在整张图的最大生成树上。（因为最大生成树能保证整张图联通，且最小边权最大）。</p>
<p>所以要先用 Kruskal 算法构建出整张图的最小生成树，然后倍增找 Lca。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h2><p>$O(mlogm+qlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, ans[Maxn];</span><br><span class="line"><span class="keyword">int</span> fa[Maxn][<span class="number">22</span>], w[Maxn][<span class="number">22</span>], dep[Maxn], lg[Maxn], vis[Maxn];</span><br><span class="line"><span class="comment">//fa 数组维护当前节点第 2 的 k 次方的祖先</span></span><br><span class="line"><span class="comment">//w 数组维护在生成树上到相应 fa 的最小边权</span></span><br><span class="line"><span class="comment">//dep 数组维护当前节点深度 lg 数组预处理 2 的 k 次方</span></span><br><span class="line"><span class="comment">//vis 数组标记在深搜找 Lca 是当前节点是否被访问过</span></span><br><span class="line"><span class="keyword">int</span> f[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">//Kruskal最小生成树用并查集维护点的连通性</span></span><br><span class="line">  <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//初始化并查集 f 数组和 lg 数组</span></span><br><span class="line">    f[i] = i, lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">  <span class="built_in">memset</span>(w, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tedge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, t;  <span class="comment">//在构建出最大生成树之前的临时边</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Tedge y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t &gt; y.t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; te[Maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, t, nxt;</span><br><span class="line">&#125; e[Maxm];  <span class="comment">//最小生成树上的边</span></span><br><span class="line"><span class="keyword">int</span> hd[Maxn], Cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  e[++Cnt] = (edge)&#123;v, t, hd[u]&#125;;</span><br><span class="line">  hd[u] = Cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fx)</span> </span>&#123;  <span class="comment">//深搜预处理 dep 数组, fa 数组和 w 数组</span></span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lg[dep[x]]; i++) &#123;</span><br><span class="line">    fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];  <span class="comment">//倍增跳 Lca</span></span><br><span class="line">                                         <span class="comment">//求 x 到 fa[x][i-1] 和 fa[x][i-1] 到 fa[x][i] 两段不相交路径上的最小值</span></span><br><span class="line">    w[x][i] = <span class="built_in">min</span>(w[x][i - <span class="number">1</span>], w[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y != fx) &#123;</span><br><span class="line">      dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">      fa[y][<span class="number">0</span>] = x;</span><br><span class="line">      w[y][<span class="number">0</span>] = e[i].t;</span><br><span class="line">      <span class="built_in">dfs</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  <span class="comment">//处理询问</span></span><br><span class="line">                         <span class="comment">//深度不齐先让 y 深度更大,方便后面处理</span></span><br><span class="line">  <span class="keyword">int</span> ans = inf;</span><br><span class="line">  <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = lg[dep[y] - dep[x]]; k + <span class="number">1</span>; k--) &#123;  <span class="comment">//先只让 y 跳 Lca 补齐深度</span></span><br><span class="line">    <span class="keyword">if</span> (dep[fa[y][k]] &gt;= dep[x]) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, w[y][k]);</span><br><span class="line">      y = fa[y][k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x == y) <span class="keyword">return</span> ans;                     <span class="comment">//如果 x 就是 y 的祖先,直接返回</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = lg[dep[x]] - <span class="number">1</span>; k + <span class="number">1</span>; k--) &#123;  <span class="comment">//x 和 y 同时跳 Lca</span></span><br><span class="line">    <span class="keyword">if</span> (fa[x][k] != fa[y][k]) &#123;</span><br><span class="line">      ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(w[x][k], w[y][k]));</span><br><span class="line">      x = fa[x][k], y = fa[y][k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = <span class="built_in">min</span>(ans, <span class="built_in">min</span>(w[y][<span class="number">0</span>], w[x][<span class="number">0</span>]));</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, t; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">    te[i].u = x, te[i].v = y, te[i].t = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Kruskal</span></span><br><span class="line">  <span class="built_in">sort</span>(te + <span class="number">1</span>, te + m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">int</span> t = te[i].t;</span><br><span class="line">    <span class="keyword">int</span> x = te[i].u, y = te[i].v, fx, fy;</span><br><span class="line">    <span class="keyword">if</span> ((fx = <span class="built_in">find</span>(x)) == (fy = <span class="built_in">find</span>(y)))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    f[fx] = fy;</span><br><span class="line">    <span class="built_in">add</span>(x, y, t);</span><br><span class="line">    <span class="built_in">add</span>(y, x, t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//预处理 Lca</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      dep[i] = <span class="number">1</span>, fa[i][<span class="number">0</span>] = i;</span><br><span class="line">      w[i][<span class="number">0</span>] = inf, <span class="built_in">dfs</span>(i, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//倍增找 Lca 回答询问.</span></span><br><span class="line">  <span class="keyword">int</span> q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) != <span class="built_in">find</span>(y))</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">LCA</span>(x, y));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P2330 [SCOI2005]繁忙的都市</title>
    <url>/Home/p2330/</url>
    <content><![CDATA[<h1 id="P2330-SCOI2005-繁忙的都市"><a href="#P2330-SCOI2005-繁忙的都市" class="headerlink" title="P2330 [SCOI2005]繁忙的都市"></a><a href="https://www.luogu.com.cn/problem/P2330">P2330 [SCOI2005]繁忙的都市</a></h1><p>看题目描述就知道是道最小生成树模板题。</p>
<h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>最小生成树</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>求一张图最小生成树。</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>无了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h2><p>$O(mlogm)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, t;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t &lt; y.t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; e[Maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, t; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">    e[i] = (edge)&#123;x, y, t&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = e[i].u, y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">    f[f[x]] = f[y];</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, e[i].t);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P2502 [HAOI2006]旅行</title>
    <url>/Home/p2502/</url>
    <content><![CDATA[<h1 id="P2502-HAOI2006-旅行"><a href="#P2502-HAOI2006-旅行" class="headerlink" title="P2502 [HAOI2006]旅行"></a><a href="https://www.luogu.com.cn/problem/P2502">P2502 [HAOI2006]旅行</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张无向图,求从给定节点 s 到 给定节点 t 的最大权值比最小权值最小的路径。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>最小生成树变式 / 最短路?</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先用并查集特判 s 和 t 不连通的情况,输出 “imposiible”。</p>
<p>其次可以排除掉与起点和终点不连通的边。</p>
<p>由于要求最大权值比最小权值最小,所以可以将所有边排序。</p>
<p>然后从小到大枚举最大边，从最大边开始从大到小枚举最小边。<br>每次判断图是否联通，如果联通，计入备选答案。</p>
<p>最后从备选答案中选择最优解。</p>
<p>时间复杂度 $O(n^2)$</p>
<p>蒟蒻我本打算用最短路，但判不了重边，且题解没有最短路，所以遗憾放弃。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(m^2)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于题目最后输出需要约分,所以需要求 gcd</span></span><br><span class="line"><span class="keyword">int</span> f[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, t;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t &lt; y.t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; e[Maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, vis[Maxn], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ans</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> mx, mn;</span><br><span class="line">&#125; a[Maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">//备选答案数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fs = <span class="built_in">find</span>(s);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i) != fs) vis[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">//正序枚举最大边</span></span><br><span class="line">    <span class="keyword">int</span> u = e[i].u, v = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!vis[u] || !vis[v]) <span class="keyword">continue</span>;       <span class="comment">//判断是否合法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) f[j] = j;  <span class="comment">//初始化联通情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j--) &#123;</span><br><span class="line">      <span class="keyword">int</span> x = e[j].u, y = e[j].v;        <span class="comment">//倒序枚举最小边</span></span><br><span class="line">      <span class="keyword">if</span> (!vis[x] || !vis[y]) <span class="keyword">continue</span>;  <span class="comment">//删除无用边</span></span><br><span class="line">      <span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">      <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        <span class="keyword">int</span> fs = <span class="built_in">find</span>(s), ft = <span class="built_in">find</span>(t);      <span class="comment">//如果合法更改联通情况</span></span><br><span class="line">        <span class="keyword">if</span> (fs == ft) &#123;                      <span class="comment">//判断当前状态是否合法</span></span><br><span class="line">          a[++cnt] = (Ans)&#123;e[i].t, e[j].t&#125;;  <span class="comment">//若合法计入备选答案</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//预处理</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i, vis[i] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, c; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;c);</span><br><span class="line">    e[i] = (edge)&#123;x, y, c&#125;;</span><br><span class="line">        <span class="keyword">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y))<span class="keyword">if</span>(fx!=fy)f[fx]=fy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">  <span class="comment">//特判不联通</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">find</span>(s) != <span class="built_in">find</span>(t)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;IMPOSSIBLE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//枚举,统计答案</span></span><br><span class="line">  <span class="built_in">solve</span>();</span><br><span class="line">  <span class="keyword">double</span> ans = <span class="number">5e4</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//在合法解中寻找最优解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (( <span class="keyword">double</span> ) a[i].mx / ( <span class="keyword">double</span> ) a[i].mn &lt; ans) &#123;</span><br><span class="line">      ans = (( <span class="keyword">double</span> ) a[i].mx / a[i].mn);</span><br><span class="line">      pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//处理,输出</span></span><br><span class="line">  <span class="keyword">if</span> (a[pos].mx % a[pos].mn == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[pos].mx / a[pos].mn);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> Gcd = <span class="built_in">gcd</span>(a[pos].mn, a[pos].mx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>, a[pos].mx / Gcd, a[pos].mn / Gcd);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P3558 [POI2013]BAJ-Bytecomputer</title>
    <url>/Home/p3558/</url>
    <content><![CDATA[<h1 id="P3558-POI2013-BAJ-Bytecomputer"><a href="#P3558-POI2013-BAJ-Bytecomputer" class="headerlink" title="P3558 [POI2013]BAJ-Bytecomputer"></a><a href="https://www.luogu.com.cn/problem/P3558">P3558 [POI2013]BAJ-Bytecomputer</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 n 的 -1, 0, 1 序列。每次可以将 $a_x += a_{x-1} (x\in [2, n])$ 求最小的修改次数使给定序列成为不降序列，无解输出 <code>-1</code>。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>线性 DP</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>$f_{i,j}$ 表示将第 $i$ 位改为 $j - 1$ 形成非降序列的最少修改次数。</p>
<p>$f_{i, 0}$ 只能由 $f_{i - 1, 0}$ 转移而来，如果：</p>
<ul>
<li>$a_i = -1$, $f_{i,0} = f_{i - 1, 0}$</li>
<li>$a_i = 0$, $f_{i,0} = f_{i-1, 0} + 1$ (把 0 拉成 -1)</li>
<li>$a_i = 1$, $f_{i,0} = f_{i-1, 0} + 1$ (把 1 拉成 -1)</li>
</ul>
<p>$f_{i, 1}$ 的转移相对复杂，注意上一个数不一定是 0，也可以是 -1。<br>也要注意一下，如果 $a_{i-1}$ 为 0 并不能对 $a_i$ 造成任何改变。</p>
<ul>
<li>$a_i = -1$, $f_{i,1}$ 失效（显然 0 无法把 -1 拉成 0）</li>
<li>$a_i = 0$, $f_{i,1} = min (f_{i-1, 0}, f_{i-1, 1})$</li>
<li>$a_i = 1$, $f_{i,1} = f_{i-1, 0} + 1$ （这一点比较难想到, -1 把 1 拉成了 0 然后接了上去）</li>
</ul>
<p>$f_{i, 2}$ 转移比较暴力，如果 $a_i \ne 1$ 就拉，否则由 $f_{i-1}$ 的三个状态取 min 转移（显然 -1, 0, 1 都可以接到 1 上构成非降序列。）</p>
<p>转移方程较多，但并不难想到，注意不要产生丢落即可。</p>
<p>边界的话除了 $f_{1, a_1  + 1} = 0$ 以外都设为 inf，最后统计答案如果都大于等于 inf 就无解，否则取 min 。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[Maxn], f[Maxn][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">  f[<span class="number">1</span>][a[<span class="number">1</span>] + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">      f[i][<span class="number">1</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">      f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">      f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">      f[i][<span class="number">2</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (f[n][<span class="number">0</span>] &gt;= inf &amp;&amp; f[n][<span class="number">1</span>] &gt;= inf &amp;&amp; f[n][<span class="number">2</span>] &gt;= inf)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;BRAK&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">min</span>(f[n][<span class="number">0</span>], <span class="built_in">min</span>(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>])));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P2798 爆弹虐场</title>
    <url>/Home/p2798/</url>
    <content><![CDATA[<h1 id="P2798-爆弹虐场"><a href="#P2798-爆弹虐场" class="headerlink" title="P2798 爆弹虐场"></a><a href="https://www.luogu.com.cn/problem/P2798">P2798 爆弹虐场</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定一张有向图，每条边有两个权值，保证权值 2 小于 权值 1，求至少包含 k 个权值 1 的MST</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>双边权最小生成树 + 二分查找（数据过水所以没用上）</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>写两个 cmp 函数，先按权值 1 排序，选择 k 条边。</p>
<p>再按权值 2 排序，选择 n-k-1 条边。</p>
<p>除此以外，就是 Kruskal 的模板了。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogm)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, Ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[Maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> u, v, T, t;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(edge x, edge y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.T &lt; y.T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(edge x, edge y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>, i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; f[i] = i; &#125;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp1);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) &#123;  <span class="comment">//跑权值 1 最小生成树</span></span><br><span class="line">    <span class="keyword">int</span> x = e[i].u, y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">    f[f[y]] = f[x], ans = <span class="built_in">max</span>(e[i].T, ans);</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">if</span> (tot == k) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(e + <span class="number">1</span>, e + m + <span class="number">1</span>, cmp2);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i) &#123;  <span class="comment">//跑权值 2 最小生成树</span></span><br><span class="line">    <span class="keyword">int</span> x = e[i].u, y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="keyword">continue</span>;</span><br><span class="line">    f[f[y]] = f[x], ans = <span class="built_in">max</span>(e[i].t, ans);</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">if</span> (tot == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ans &lt; Ans) &#123;</span><br><span class="line">    Ans = ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, T, t; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;T, &amp;t);</span><br><span class="line">    e[i] = (edge)&#123;x, y, T, t&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">work</span>(k);  <span class="comment">//这本应该是二分/kk</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P3275 [SCOI2011]糖果</title>
    <url>/Home/p3275/</url>
    <content><![CDATA[<h1 id="P3275-SCOI2011-糖果"><a href="#P3275-SCOI2011-糖果" class="headerlink" title="P3275 [SCOI2011]糖果"></a><a href="https://www.luogu.com.cn/problem/P3275">P3275 [SCOI2011]糖果</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定 n 个点和 5 种相等或不等的约束条件共 K 个,求能否同时满足所有约束条件。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>差分约束 + SPAF</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>无了</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nm)$</p>
<h2 id="题目代码"><a href="#题目代码" class="headerlink" title="题目代码:"></a>题目代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ps:这是一个无脑卡常后的代码…</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> s = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (s &lt; <span class="string">&#x27;0&#x27;</span> || s &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">    s = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (s &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">    x = x * <span class="number">10</span> + s - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  x *= f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, t, nxt;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[Maxn], cnt[Maxn], Cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  e[++Cnt].v = v, e[Cnt].t = t, e[Cnt].nxt = head[u], head[u] = Cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[Maxn], book[Maxn];</span><br><span class="line">queue&lt; <span class="keyword">int</span> &gt; q;</span><br><span class="line"><span class="comment">//SPAF 判负环</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPAF</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  dis[<span class="number">0</span>] = <span class="number">0</span>, book[<span class="number">0</span>] = <span class="number">1</span>, cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (cnt[x] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    book[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="keyword">int</span> y = e[i].v, z = e[i].t;</span><br><span class="line">      <span class="keyword">if</span> (dis[y] &lt; dis[x] + z) &#123;</span><br><span class="line">        dis[y] = dis[x] + z;</span><br><span class="line">        <span class="keyword">if</span> (!book[y]) q.<span class="built_in">push</span>(y), book[y] = <span class="number">1</span>, cnt[y]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">read</span>(n), <span class="built_in">read</span>(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//差分约束建边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, k, x, y; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="built_in">read</span>(k), <span class="built_in">read</span>(x), <span class="built_in">read</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="built_in">add</span>(x, y, <span class="number">0</span>), <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>) <span class="built_in">add</span>(x, y, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">3</span>) <span class="built_in">add</span>(y, x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">4</span>) <span class="built_in">add</span>(y, x, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">5</span>) <span class="built_in">add</span>(x, y, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(k &amp; <span class="number">1</span>) &amp;&amp; x == y) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">SPAF</span>(n)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//输出最小糖果数,也就是这张图最短路径树的大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">      ans += dis[i] * <span class="number">1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P4171 [JSOI2010] 满汉全席</title>
    <url>/Home/p4171/</url>
    <content><![CDATA[<h1 id="P4171-JSOI2010-满汉全席"><a href="#P4171-JSOI2010-满汉全席" class="headerlink" title="P4171 [JSOI2010] 满汉全席"></a><a href="https://www.luogu.com.cn/problem/P4171">P4171 [JSOI2010] 满汉全席</a></h1><h2 id="题目翻译："><a href="#题目翻译：" class="headerlink" title="题目翻译："></a>题目翻译：</h2><p>给定 n 个点，每个点有两个状态和 m 组约束条件，每组包括两个约束条件 $(opt,i)$ 表示第 $i$ 个点状态必须为 $opt, opt\in[0, 1]$ 。求能否 $m$ 组条件都至少满足一个。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>2-sat + tarjan 缩点</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>无了</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogn)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将 1 个点 x 拆成 2个点,m 为 x,h 为 x+n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt, n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge)&#123;v, hd[u]&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> low[Maxn], dfn[Maxn], tim;</span><br><span class="line"><span class="keyword">int</span> col[Maxn], vis[Maxn];</span><br><span class="line"><span class="keyword">int</span> stc[Maxn], top;</span><br><span class="line"><span class="comment">//dfn 表示 深搜时间戳,low 表示通过非搜索树边能到达的最远祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  low[x] = dfn[x] = ++tim;  <span class="comment">//tarjan 算法 dfn 时间戳</span></span><br><span class="line">  stc[++top] = x;</span><br><span class="line">  vis[x] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[y]) &#123;  <span class="comment">//如果 y 还未访问</span></span><br><span class="line">      <span class="built_in">tarjan</span>(y);</span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[y])  <span class="comment">//如果 y 已访问说明当前边是非树边,更新 low</span></span><br><span class="line">      low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (low[x] == dfn[x]) &#123;  <span class="comment">//缩点</span></span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">while</span> ((y = stc[top--]) != <span class="number">0</span>) &#123;</span><br><span class="line">      vis[y] = <span class="number">0</span>;</span><br><span class="line">      col[y] = x;</span><br><span class="line">      <span class="keyword">if</span> (y == x) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  <span class="comment">//由于多组询问要及时清空数组。</span></span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(hd, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(hd));</span><br><span class="line">  <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(low));</span><br><span class="line">  <span class="built_in">memset</span>(col, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(col));</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dfn));</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> K;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;K);</span><br><span class="line">  <span class="keyword">while</span> (K--) &#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">char</span> t1, t2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      cin &gt;&gt; t1 &gt;&gt; x &gt;&gt; t2 &gt;&gt; y;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">若两个点都要为 1 ,</span></span><br><span class="line"><span class="comment">则将点 1 的 2 向点 2 的 1 连边,</span></span><br><span class="line"><span class="comment">并将点 2 的 2 向点 1 的 1 连边,</span></span><br><span class="line"><span class="comment">表示两个约束条件满足 1 个即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      <span class="keyword">if</span> (t1 == <span class="string">&#x27;m&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">          <span class="built_in">add</span>(x + n, y), <span class="built_in">add</span>(y + n, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">add</span>(x + n, y + n), <span class="built_in">add</span>(y, x);  <span class="comment">//同上</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t1 == <span class="string">&#x27;h&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t2 == <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">          <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y + n, x + n);  <span class="comment">//同上</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">add</span>(x, y + n), <span class="built_in">add</span>(y, x + n);  <span class="comment">//同上</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">      <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="comment">//若有 1 个节点的 2 个状态在同一连通块中,则说明无解。</span></span><br><span class="line">      <span class="keyword">if</span> (col[i] == col[i + n]) flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;GOOD\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;BAD\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P4302 [SCOI2003]字符串折叠</title>
    <url>/Home/p4302/</url>
    <content><![CDATA[<h1 id="P4302-SCOI2003-字符串折叠"><a href="#P4302-SCOI2003-字符串折叠" class="headerlink" title="P4302 [SCOI2003]字符串折叠"></a><a href="https://www.luogu.com.cn/problem/P4302">P4302 [SCOI2003]字符串折叠</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个字符串，每次可以将一个循环子串 $SSS… S$ 折叠为 $n(S)$ 。求进行多次折叠后最短长度。 $n \le 100$</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>区间 DP</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>考虑区间 DP，设 $f_{l, r}$ 表示 $[l, r]$ 内折叠后的最小长度。<br>先按照区间 DP 常用套路，枚举断点来进行合并，如果判定枚举的当前字串是循环子串，更新 DP 数组为 $f_{l,r} = \min(f_{l,r}, numlen + f_{l, l + k - 1} + 2)$ 。<br>其中 k 为循环节长度，注意这里是循环节的<strong>DP 数组</strong>， 而不是循环节长度，因为可能会出现<strong>嵌套折叠</strong>的情况，如：$AB ABC ABC ABC AB ABC ABC ABC$ 会折叠为 $2(AB3(ABC))$。<br> numlen 为循环节个数的数字长度，2 为括号长度。<br>取最小值是因为折叠之后<strong>不一定比之前优</strong>，如：$AA$ 长度为 2，折叠之后 $2(A)$ 长度为 4。<br>进行判定时可以用 Hash 来比对，但由于本题数据范围较小，直接暴力扫描也是可以的。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^4)$ 或 $O(n^3)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> IO <span class="comment">// 快读</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[Maxn], tmp[Maxn];</span><br><span class="line"><span class="keyword">int</span> len[Maxn], f[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里保留扫描判循环节。</span></span><br><span class="line">  <span class="keyword">if</span> ((r - l + <span class="number">1</span>) % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    tmp[i] = s[l + i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i += k) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j)</span><br><span class="line">      <span class="keyword">if</span> (tmp[j] != s[i + j - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 预处理数字长度</span></span><br><span class="line">  len[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, p = <span class="number">10</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    len[i] = len[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i == p) len[i]++, p *= <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 读入</span></span><br><span class="line">  cin &gt;&gt; (s + <span class="number">1</span>); <span class="keyword">int</span> n = <span class="built_in">strlen</span> (s + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 初始化 DP 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) f[i][j] = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][i] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 区间 DP 过程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> Len = <span class="number">1</span>; Len &lt;= n; ++Len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; (l + Len - <span class="number">1</span>) &lt;= n; ++l) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = l + Len - <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 子段间合并</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k)</span><br><span class="line">        f[l][r] = <span class="built_in">min</span> (f[l][r], f[l][k] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">      <span class="comment">// 处理循环</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; r - l + <span class="number">1</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span> (l, r, k))</span><br><span class="line">        f[l][r] = <span class="built_in">min</span> (f[l][r], len[(r - l + <span class="number">1</span>) / k] + f[l][l + k - <span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, f[<span class="number">1</span>][n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P4552 [Poetize6] IncDec Sequence</title>
    <url>/Home/p4552/</url>
    <content><![CDATA[<h1 id="早期题解"><a href="#早期题解" class="headerlink" title="早期题解"></a>早期题解</h1><span id="more"></span>
<h1 id="P4552-Poetize6-IncDec-Sequence"><a href="#P4552-Poetize6-IncDec-Sequence" class="headerlink" title="P4552 [Poetize6] IncDec Sequence"></a><a href="https://www.luogu.com.cn/problem/P4552">P4552 [Poetize6] IncDec Sequence</a></h1><p>求出a的差分序列b,其中 $b_{1}=a_{1}$，$b_{i}=a_{i}-a_{i-1}(2≤i≤n)$。令 $b_{n+1}=0$。(一会有大用)</p>
<p>题目对序列a的操作，相当于每次可以选出 $b_{1},b_{2},…,b_{n+1}$ 中的任意两个数，一个加1，另一个减1。目标是把 $b_{2},b_{3},…,b_{n}$ 变为全零。最终得到的数列 $a$ 就是由 $n$ 个 $b_{1}$ 构成的。</p>
<p>从 $b_{1},b_{2},…,b_{n+1}$ 中任选两个数的方法可分为四类:</p>
<ol>
<li>选 $b_{i}$ 和 $b_{j}$，其中 $2≤i,j≤n$。这种操作会改变 $b_{2},b_{3},…,b_{n}$ 中两个数的值。应该在保证 $b_{i}$ 和 $b_{j}$ 一正一负的前提下，尽量多地采取这种操作，更快地接近目标。</li>
<li>选 $b_{1}$ 和 $b_{j}$，其中 $2≤j≤n$。</li>
<li>选 $b_{i}$ 和 $b_{n+1}$，其中 $2≤i≤n$。</li>
<li>选 $b_{1}$ 和 $b_{n+1}$，这种情况没有意义，因为它不会改变 $b_{2},b_{3},…,b_{n}$ 的值，相当于浪费了一次操作，一定不是最优解。</li>
</ol>
<p>设 $b_{2},b_{3},…,b_{n}$ 中正数总和为 $p$，负数总和的绝对值为 $q$。首先以正负数配对的方式尽量执行第1类操作，可执行 $\min(p,q)$ 次。剩余 $|p-q|$ 个未配对，每个可以选与 $b_{n}$ 或 $b_{n+1}$ 配对，即执行第2或3类操作，共需 $|p-q|$ 次。</p>
<p>综上所述，最少操作次数为 $\min(p,q)+|p-q|=\max(p,q)$ 次。根据 $|p-q|$ 次第2、3类操作的选择情况，能产生 $|p-q|+1$ 种不同的 $b_{1}$ 的值，即最终得到的序列a可能有 $|p-q|+1$ 种。</p>
<p>摘自《算法竞赛进阶指南》</p>
<p>知道这些之后，你就会惊奇的发现，这道题不用差分序列！<br>只要在读入时维护正数的和以及负数和的绝对值就可以了，避免了不必要的空间浪费。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[Maxn], b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">0</span>, q = <span class="number">0</span>;  <span class="comment">//分别维护正数的和以及负数和的绝对值</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[<span class="number">1</span>]);  <span class="comment">//要先读入第一个数，因为第一个数没有差分</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);  <span class="comment">//读入</span></span><br><span class="line">    b = a[i] - a[i - <span class="number">1</span>];   <span class="comment">//你可以理解为一个临时的差分序列</span></span><br><span class="line">    <span class="keyword">if</span> (b &gt;= <span class="number">0</span>) p += b;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) q += -b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">max</span>(p, q));                      <span class="comment">//输出最少操作次数</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, p &gt; q ? p - q + <span class="number">1</span> : q - p + <span class="number">1</span>);  <span class="comment">//输出结果数，即|p-q|+1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Summary</tag>
        <tag>EP</tag>
      </tags>
  </entry>
  <entry>
    <title>P5020 [NOIP2018 提高组] 货币系统</title>
    <url>/Home/p5020/</url>
    <content><![CDATA[<h1 id="P5020-NOIP2018-提高组-货币系统"><a href="#P5020-NOIP2018-提高组-货币系统" class="headerlink" title="P5020 [NOIP2018 提高组] 货币系统"></a><a href="https://www.luogu.com.cn/problem/P5020">P5020 [NOIP2018 提高组] 货币系统</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定 n 种面值不同的货币，求与这 n 种货币组成的系统等价的系统中 <strong>用到货币最少的系统</strong> 的货币数量 m。<br>定义系统等价为任意一种面值要么两个系统都能表示出来，要么都不能表示出来。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>完全背包</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>想到面值表示就想到了完全背包（厕所灵感）</p>
<p>可以发现如果一种货币本身可以被另一种货币表示出来，那么由它参与的面值也一定可以由除它以外的货币表示出来。</p>
<p>所以我们只要找出有多少种货币本身是被其他货币表示出来的即可。</p>
<p>然后可以发现一种货币只可能被比他小的货币表示出来。</p>
<p>所以可以先把货币从小到大排序，然后从小到大枚举货币跑完全背包，其中 $f_j$ 存储 0/1 表示面值 $j$ 能否被表示出来。如果发现某个货币本身可以被表示出来就更新答案 ans++;</p>
<p>最后输出 n - ans 即可。</p>
<p>状态转移方程也很简单:</p>
<script type="math/tex; mode=display">f_j = max(f_j, f_{j-a[i]})</script><h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n\times max(a_i))$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2.5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[Maxn], f[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, mx; <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    mx = <span class="built_in">max</span> (mx, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span> (f, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f));</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f[a[i]]) ans ++;</span><br><span class="line">    f[a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= mx; ++j) &#123;</span><br><span class="line">      f[j] = <span class="built_in">max</span> (f[j], f[j-a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, n - ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t; <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span> (t--) <span class="built_in">work</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P5322 [BJOI2019]排兵布阵</title>
    <url>/Home/p5322/</url>
    <content><![CDATA[<h1 id="P5322-BJOI2019-排兵布阵"><a href="#P5322-BJOI2019-排兵布阵" class="headerlink" title="P5322 [BJOI2019]排兵布阵"></a><a href="https://www.luogu.com.cn/problem/P5322">P5322 [BJOI2019]排兵布阵</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>共有 s 个序列， $a_1, a_2, \dots a_s$，每个序列 n 个节点 m 个物品，求构造第 s + 1 个序列，仍满足共有 m 个物品，使得 </p>
<script type="math/tex; mode=display">\sum_{i = 1} ^ n i \times \sum_{j = 1} ^ s [a_{s + 1, i} > 2 \times a_{j, i}]</script><p>最大。只要求输出最大值即可。</p>
<span id="more"></span>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>线性 DP </p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>根据题目描述和数据范围，可以考虑设 $f_{i,j}$ 表示考虑到 $i$ 位置时一共放了 $j$ 个物品的最大价值。</p>
<p>很容易就可以知道每个位置一定是刚好超过 $2 \times a_{1, i}$ ~ $2\times a_{s, i}$ 中某个值时最优。状态转移方程即为 $f_i,j = max (f_{i - 1, j - k} + val_{i, k})$ 其中 $val_{i, k}$ 即为在 i 点放 k 个物品的得分，可以预处理出来。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nms)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">2e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[Maxn][Maxn];</span><br><span class="line"><span class="keyword">int</span> v[Maxn][Maxm], f[Maxn][Maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s, n, m;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;s, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[j][i]);</span><br><span class="line">      a[j][i] = a[j][i] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> P;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">sort</span> (a[i] + <span class="number">1</span>, a[i] + s + <span class="number">1</span>);</span><br><span class="line">    P = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt;= a[i][P] &amp;&amp; P &lt;= s) &#123;</span><br><span class="line">        P ++;</span><br><span class="line">      &#125;</span><br><span class="line">      v[i][j] = (P - <span class="number">1</span>) * i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">      f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= s; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j - a[i][k] &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span> (f[i][j], f[i<span class="number">-1</span>][j-a[i][k]] + v[i][a[i][k]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, f[n][m]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>P6473 [NOI Online 2 入门组] 未了</title>
    <url>/Home/p6473/</url>
    <content><![CDATA[<h1 id="早期题解"><a href="#早期题解" class="headerlink" title="早期题解"></a>早期题解</h1><span id="more"></span>
<h1 id="P6473-NOI-Online-2-入门组-未了"><a href="#P6473-NOI-Online-2-入门组-未了" class="headerlink" title="P6473 [NOI Online #2 入门组] 未了"></a><a href="https://www.luogu.com.cn/problem/P6473">P6473 [NOI Online #2 入门组] 未了</a></h1><p>这道题不用二分！！！</p>
<ul>
<li><p>其实不难想到，高度高的魔法比高度低的魔法要顶用，所以优先考虑用高度高的魔法。</p>
</li>
<li><p>其次，这道题不要求在线，可以将查询从小到大排序后离线扫一遍。</p>
</li>
<li><p>最终复杂度 $O(nlogn)$。</p>
</li>
</ul>
<p>再说细节：</p>
<p>这道题大家应该都能想到要用前缀和。</p>
<ul>
<li><p>不用魔法是，需要爬的高度就是 坡长。</p>
</li>
<li><p>用上最高的魔法时，高度即是 坡长+使用最高魔法的高度。</p>
</li>
<li><p>再用上次高的魔法时，高度即是 坡长+使用最高魔法的高度+使用次高魔法的高度。</p>
</li>
<li><p>以此类推</p>
</li>
</ul>
<p>所以我们可以用前缀和来维护。</p>
<p>将 ans 数组初始化为 -1。因为排序过，所以询问数组满足单调性，前面无法做到，后面就更无法作到，所以如果扫到哪里发现做不到，就直接 break。</p>
<p>记着开 long long ！！！</p>
<p>Code for P6473 [NOI Online #2 入门组]未了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], s[Maxn], ans[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ask</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id, que;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Ask x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> que &lt; x.que;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Q[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//	freopen(&quot;endless.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">  <span class="comment">//	freopen(&quot;endless.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> n, L, v, q;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;n, &amp;L, &amp;v);</span><br><span class="line">  a[<span class="number">0</span>] = L, s[<span class="number">0</span>] = L;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;q);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;Q[i].que);</span><br><span class="line">    Q[i].que *= v;</span><br><span class="line">    Q[i].id = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(Q + <span class="number">1</span>, Q + q + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (s[j] &lt;= Q[i].que &amp;&amp; j &lt;= n) j++;</span><br><span class="line">    <span class="keyword">if</span> (s[j] &gt; Q[i].que)</span><br><span class="line">      ans[Q[i].id] = j;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Summary</tag>
        <tag>EP</tag>
      </tags>
  </entry>
  <entry>
    <title>schedule</title>
    <url>/Home/schedule/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">周一</th>
<th style="text-align:center">周二</th>
<th style="text-align:center">周三</th>
<th style="text-align:center">周四</th>
<th style="text-align:center">周五</th>
<th style="text-align:center">周六</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第1节</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">生物</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">历史</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">物理</td>
</tr>
<tr>
<td style="text-align:center">第2节</td>
<td style="text-align:center">物理</td>
<td style="text-align:center">化学</td>
<td style="text-align:center">物理</td>
<td style="text-align:center">化学</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">化学</td>
</tr>
<tr>
<td style="text-align:center">第3节</td>
<td style="text-align:center">历史</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">地理</td>
<td style="text-align:center">生物</td>
<td style="text-align:center">体育</td>
<td style="text-align:center">地理</td>
</tr>
<tr>
<td style="text-align:center">第4节</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">物理</td>
<td style="text-align:center">语文</td>
</tr>
<tr>
<td style="text-align:center">第5节</td>
<td style="text-align:center">化学</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">物理</td>
<td style="text-align:center">政治</td>
<td style="text-align:center">生物</td>
</tr>
<tr>
<td style="text-align:center">第6节</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">微机</td>
<td style="text-align:center">考试</td>
<td style="text-align:center">语文</td>
<td style="text-align:center">艺术</td>
<td style="text-align:center">英语</td>
</tr>
<tr>
<td style="text-align:center">第7节</td>
<td style="text-align:center">政治</td>
<td style="text-align:center">体育</td>
<td style="text-align:center">考试</td>
<td style="text-align:center">英语</td>
<td style="text-align:center">数学</td>
<td style="text-align:center">数学</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-10-21 CSP 考前模拟赛题解</title>
    <url>/Home/solution-2021-10-21/</url>
    <content><![CDATA[<h1 id="2021-10-21-CSP-考前模拟赛题解"><a href="#2021-10-21-CSP-考前模拟赛题解" class="headerlink" title="2021-10-21 CSP 考前模拟赛题解"></a>2021-10-21 CSP 考前模拟赛题解</h1><span id="more"></span>
<h1 id="T1-Divisors"><a href="#T1-Divisors" class="headerlink" title="T1. Divisors"></a><a href="https://sjzezoj.com/contest/166/problem/90">T1. Divisors</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $m$ 的数列 $a_1, a_2, \dots a_m$，和区间 $[1, n]$。求 $\forall k \in [0, m]$, 在区间 $[1, n]$ 里有多少正整数是 $a$ 中恰好 $k$ 个数的约数。</p>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>因数分解，STL + map</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先看到约数个数的问题，就想到了因数分解。</p>
<p>枚举每个数 $a_i$ 的约束 $d_1, d_2, \dots d_x$。</p>
<p>用 $map$ 记录每个约数出现的次数，即 $map_d = \sum_{k = 1}^n[d|a_k]$ </p>
<p>同时记录所有因数的出现的次数（非重叠） cnt。</p>
<p>最后用迭代器遍历一遍 map, 统计答案。$ans_x = \sum [map_d == x]$</p>
<p>当 k = 0 时，答案即为非因数个数 n - cnt。</p>
<p>同时注意对 $a_x$ 进行因数拆分时注意判断 $d &gt; n$。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(mlogm\times a_x\sqrt a_x)$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[Maxn], ans[Maxn], cnt, n; </span><br><span class="line">map &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i * i &lt; x &amp;&amp; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!p[i]) cnt++; p[i]++; </span><br><span class="line">      <span class="keyword">if</span> (x / i &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (!p[x/i]) cnt++; p[x/i]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i * i == x &amp;&amp; i &lt;= n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p[i]) cnt++;</span><br><span class="line">    p[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> m; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">split</span> (a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = p.<span class="built_in">begin</span> (); i != p.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">    ans[i -&gt; second] ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> ( <span class="string">&quot;%d\n&quot;</span>, n - cnt );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Market"><a href="#T2-Market" class="headerlink" title="T2.Market"></a><a href="https://sjzezoj.com/contest/166/problem/973">T2.Market</a></h1><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>共有 $n$ 种物品，个数为 $1$，体积为 $c_i$，价值为 $v_i$，开放时间为 $t_i$，共有 $m$ 次询问，每次询问在时间 $T_i$ 时，体积为 $V_i$ 的背包所能容纳的最大价值。</p>
<p>其中 $c_i$ 远大于 $v_i$</p>
<h2 id="题目正解：-1"><a href="#题目正解：-1" class="headerlink" title="题目正解："></a>题目正解：</h2><p>01 背包 + 离线 + 交换主维</p>
<h2 id="题目思路：-1"><a href="#题目思路：-1" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先一眼就能看出来的是 01 背包，然后我们要考虑优化。</p>
<p>每次询问找到可用的所有物品并跑一边背包肯定是不现实的，所以就用到了离线排序思想。</p>
<p>将物品和询问按照时间排序。每次更新背包只要跑一边新加入的物品。</p>
<p>然后发现这样只能拿到 60’ 因为 c 太大，数组开不下。这时我们就要用到交换两维的思想，枚举 v，让 c 尽可能小。然后再二分 f 数组，求得 <strong>最后一个大于等于 $V_i$ 的 c 值所对应的下标</strong></p>
<h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nv)$</p>
<h2 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shops</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> C, V, T;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Shops y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> T &lt; y.T;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Go</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> T, M, id;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Go y) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> T &lt; y.T;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; q[Maxm];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[Maxm]; </span><br><span class="line"><span class="keyword">int</span> Lst, lst, c, Ans[Maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &gt;= a[i].V; --j)</span><br><span class="line">    f[j] = <span class="built_in">min</span> (f[j], f[j - a[i].V] + <span class="number">1ll</span> * a[i].C);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = c; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">    f[j] = <span class="built_in">min</span> (f[j], f[j+<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  c = n * <span class="number">300</span>; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].C, &amp;a[i].V, &amp;a[i].T);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].T, &amp;q[i].M);</span><br><span class="line">    q[i].id = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span> (q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span> (f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f)); </span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">int</span> lans = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> T = q[i].T;</span><br><span class="line">    <span class="keyword">while</span> (a[j+<span class="number">1</span>].T &lt;= T &amp;&amp; j + <span class="number">1</span> &lt;= n) &#123;</span><br><span class="line">      j++, <span class="built_in">check</span> (j);</span><br><span class="line">    &#125;</span><br><span class="line">    lans = <span class="built_in">upper_bound</span> (f + <span class="number">1</span>, f + c + <span class="number">1</span>, <span class="number">1ll</span> * q[i].M) - f - <span class="number">1</span>;</span><br><span class="line">    Ans[q[i].id] = lans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i ) &#123;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-披风"><a href="#T3-披风" class="headerlink" title="T3.披风"></a><a href="https://sjzezoj.com/contest/166/problem/1106">T3.披风</a></h1><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一张有向图，每个点有点权。试找到一条路径，使得该路径上的点权最大值减去点权最小值最大，问这个差最大是多少。</p>
<h2 id="题目正解：-2"><a href="#题目正解：-2" class="headerlink" title="题目正解："></a>题目正解：</h2><p>tarjan 缩点 + 拓扑 DP \ 记忆化搜索</p>
<h2 id="题目思路：-2"><a href="#题目思路：-2" class="headerlink" title="题目思路："></a>题目思路：</h2><p>看到有向图关于链的问题就能大概想到拓扑排序或者 <del>爆搜</del> 记忆化搜索 。它的前置自然是缩点构造 DAG。</p>
<h2 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n + m)$</p>
<h2 id="题目代码：-2"><a href="#题目代码：-2" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt, u;</span><br><span class="line">&#125; e[Maxn * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge) &#123;v, hd[u], u&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[Maxn], low[Maxn], tim;</span><br><span class="line"><span class="keyword">bool</span> vis[Maxn];</span><br><span class="line"><span class="keyword">int</span> stc[Maxn], top;</span><br><span class="line"><span class="keyword">int</span> col[Maxn], mn[Maxn], mx[Maxn], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  dfn[x] = low[x] = ++tim; vis[x] = <span class="number">1</span>;</span><br><span class="line">  stc[++top] = x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i =hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[y]) </span><br><span class="line">      <span class="built_in">dfs</span>(y), low[x] = <span class="built_in">min</span> (low[x], low[y]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (vis[y]) </span><br><span class="line">      low[x] = <span class="built_in">min</span> (low[x], dfn[y]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">while</span> ((y = stc[top--]) != <span class="number">0</span>) &#123;</span><br><span class="line">      col[y] = x; vis[y] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (x == y) <span class="keyword">break</span>;</span><br><span class="line">      mx[x] = <span class="built_in">max</span> (mx[x], mx[y]);</span><br><span class="line">      mn[x] = <span class="built_in">min</span> (mn[x], mn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; g[Maxn]; </span><br><span class="line"><span class="keyword">int</span> in[Maxn], f[Maxn], h[Maxn];</span><br><span class="line"></span><br><span class="line">queue &lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;mx[i]);</span><br><span class="line">    mn[i] = mx[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">add</span> (x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i]) <span class="built_in">dfs</span> (i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = col[e[i].u], y = col[e[i].v];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">    g[x].<span class="built_in">push_back</span> (y); in[y]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!in[i]) q.<span class="built_in">push</span> (i);</span><br><span class="line">    f[i] = mn[i], h[i] = mx[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span> ()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = q.<span class="built_in">front</span> (); q.<span class="built_in">pop</span> ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y : g[x]) &#123;</span><br><span class="line">      in[y]--;</span><br><span class="line">      f[y] = <span class="built_in">min</span> (f[x], f[y]);</span><br><span class="line">      h[y] = <span class="built_in">max</span> (h[x], h[y]);</span><br><span class="line">      ans = <span class="built_in">max</span> (ans, mx[y] - f[y]);</span><br><span class="line">      ans = <span class="built_in">max</span> (ans, h[y] - mn[y]);</span><br><span class="line">      <span class="keyword">if</span> (!in[y]) q.<span class="built_in">push</span> (y);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-子弹"><a href="#T4-子弹" class="headerlink" title="T4.子弹"></a><a href="https://sjzezoj.com/contest/166/problem/1107">T4.子弹</a></h1><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>$n$ 个点，每个点两个数共 $2 \times n$ 个数，可以交换任意两个数，要求最小的修改数使每个点两个数的差值比 c 小。</p>
<h2 id="题目正解：-3"><a href="#题目正解：-3" class="headerlink" title="题目正解："></a>题目正解：</h2><p>搜索</p>
<h2 id="题目思路：-3"><a href="#题目思路：-3" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先可以确定的是不存在某个点中两个数都是从其他点换过来的。这样肯定不优。</p>
<p>然后我们就可以搜索从 1 开始让每个点依次满足条件。最终得到答案，可以用迭代加深优化。</p>
<h2 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(\text{玄学})$</p>
<h2 id="题目代码：-3"><a href="#题目代码：-3" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[Maxn][<span class="number">2</span>], n, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x == n + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">abs</span> (a[x][<span class="number">0</span>] - a[x][<span class="number">1</span>]) &lt;= c) </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span> (x + <span class="number">1</span>, res)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = x + <span class="number">1</span>; y &lt;= n; ++y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span> (a[x][<span class="number">0</span>] - a[y][<span class="number">0</span>]) &lt;= c) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (a[x][<span class="number">1</span>], a[y][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span> (x + <span class="number">1</span>, res - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span> (a[x][<span class="number">1</span>], a[y][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span> (a[x][<span class="number">0</span>] - a[y][<span class="number">1</span>]) &lt;= c) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (a[x][<span class="number">1</span>], a[y][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span> (x + <span class="number">1</span>, res - <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span> (a[x][<span class="number">1</span>], a[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;c) ;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i][<span class="number">0</span>], &amp;a[i][<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">1</span>, i)) &#123;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, i); <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Graph-Theory</tag>
        <tag>DP</tag>
        <tag>Math</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-12-12 模拟赛总结</title>
    <url>/Home/solution-2021-12-12/</url>
    <content><![CDATA[<h1 id="2021-12-12-模拟赛总结"><a href="#2021-12-12-模拟赛总结" class="headerlink" title="2021-12-12 模拟赛总结"></a>2021-12-12 模拟赛总结</h1><p>2021-12-12 双十二挂分大赛。。。</p>
<span id="more"></span>
<h2 id="考场部分简结"><a href="#考场部分简结" class="headerlink" title="考场部分简结"></a>考场部分简结</h2><p>上来先扫题，T1 貌似线性筛能骗到分？但记不太清了。先跳过，T2 好像搜索题，T3 貌似也是呢。。<br>看 T4 好像是树剖，开始刚 T4 。T4 一开始看了半小时没思路，开始写暴力，写着写着，好像会正解了。$100L+$ Wasted<br>调完 T4 写 T2，调了半天样例过了，貌似 1s 跑的出来。<br>开始写 T1 ，线性筛没调出来，转质因数分解，看了眼题面 <code>输入包含若干组数据，每组数据只包含一行，即数 N</code>。难道只是样例偷懒了？又害怕输入停止写错了，于是改成了单测。<br>吃完饭回来，T1 就是多测。。。 T2 没清空且 <code>&quot;%d\n&quot;</code> 写成了 <code>&quot;%d &quot;</code> 于是 $156 -&gt; 100$ 。</p>
<h2 id="题解部分"><a href="#题解部分" class="headerlink" title="题解部分"></a>题解部分</h2><h1 id="T1-NonPrime"><a href="#T1-NonPrime" class="headerlink" title="T1. NonPrime"></a><a href="https://sjzezoj.com/contest/179/problem/1168">T1. NonPrime</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>令 $d(x)$ 为约数个数，给定 $n$, 求最大正整数 $x\in [1, n]$ 令 $\forall y\in [1, x), d(y) &lt; d(x)$ 。</p>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>搜索 + 剪枝</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>考虑利用 $\text{若} n = \prod p_i^{k_i}, \text{则} d(n) = \prod (1 + k_i)$ 这个性质，枚举质数来求。<br>感性理解一下设当前各质数的指数相同，若增加一个质数，所得贡献是相同的，但小质数对 $n$ 增长的贡献较小，所以各质数，由小到大，的指数应该是递减的。<br>得到这条性质后，我们发现 $\prod_1^9 p_i, 即 2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 \times 19 \times 23 &gt; 3e9$<br>所以只需要将 9 个素数表打出来，然后搜索即可。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(\text{玄学})$</p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define ktj tag</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans, pos, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> now, <span class="keyword">int</span> cnt, <span class="keyword">int</span> MAX)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cur == Maxn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; ans || (cnt == ans &amp;&amp; now &lt; pos))</span><br><span class="line">       ans = cnt, pos = now;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, P = <span class="number">1</span>; now * P &lt;= n &amp;&amp; i &lt;= MAX; ++i, P *= p[cur]) &#123;</span><br><span class="line">    <span class="built_in">dfs</span> (cur + <span class="number">1</span>, now * P, cnt * (<span class="number">1</span> + i), <span class="built_in">min</span> (MAX, i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ans = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">dfs</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n)) <span class="built_in">work</span> (n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-小T树"><a href="#T4-小T树" class="headerlink" title="T4. 小T树"></a><a href="https://sjzezoj.com/contest/179/problem/1172">T4. 小T树</a></h1><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一颗 1 为根树，两种操作：</p>
<ul>
<li>修改：输入 $x, v$ 。将 x 及子树中，深度奇偶性和 x 相同的点权值加 $v$ , 否则减 $v$。</li>
<li>单点查询：输入 $x$ ，求 $x$ 的权值。</li>
</ul>
<h2 id="题目正解-1："><a href="#题目正解-1：" class="headerlink" title="题目正解 1："></a>题目正解 1：</h2><p>树剖 + 线段树（树状数组）</p>
<h2 id="题目正解-2："><a href="#题目正解-2：" class="headerlink" title="题目正解 2："></a>题目正解 2：</h2><p>双树状数组</p>
<h2 id="题目思路：-1"><a href="#题目思路：-1" class="headerlink" title="题目思路："></a>题目思路：</h2><p>其实这两种思路完全不同。<br>你考虑你要将子树中深度为奇数的点和深度为偶数的点分别修改，但这无论如何无法构成连续区间。<br>所以可以考虑将他们拆成两部分连续区间，这就是双树状数组的做法。<br>但如果没有想到这种做法，没关系，慢慢来。<br>先考虑朴素做法，每次修改时，先令 $\mu = 1$, 每向下跳一层 $\mu = -\mu$, 则 $a[x] += \mu \times v$ 。<br>单点统计贡献。<br>适用于 Subtask 1</p>
<p>然后发现，当修改数远大于查询数时，修改时可以打标记。<br>查询时，可以向上跳链，仍令 $\mu = 1$，每向上跳一层 $\mu = -\mu$ ,$ans$ 初值为 $a_x$ ，每向上跳一层，$ans += \mu \times t_x$ 。<br>适用于 Subtask 2</p>
<p>然后你发现这一条链已经可以成连续区间了。<br>但考虑正负变化，你可以钦定深度为奇数的点贡献为正，深度为偶数的点贡献为负，然后套一个树剖统计从 $x$ 到根的的贡献和。$\text{若} dep_x \And 1, ans = sum + a_x \text{否则}, ans = -sum + a_x$</p>
<h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nlogn)$</p>
<h2 id="题目代码-Sb2-没用上-："><a href="#题目代码-Sb2-没用上-：" class="headerlink" title="题目代码(Sb2 没用上)："></a>题目代码(Sb2 没用上)：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define ktj tag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1.5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, nxt;</span><br><span class="line">&#125; e[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> hd[Maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = (edge) &#123;v, hd[u]&#125;;</span><br><span class="line">  hd[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Sb1 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  fa[x] = f;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">init</span> (y, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">  a[x] += tp * v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">add</span> (y, v, -tp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="keyword">if</span> (tp == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> (), v = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="built_in">add</span> (s, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span> (s));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Sb2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tag[Maxn], fa[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  fa[x] = f;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">init</span> (y, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">  tag[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tp, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">  ans += tag[x] * tp;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ask</span> (fa[x], -tp, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">init</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> tp = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="keyword">if</span> (tp == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> (), v = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="built_in">add</span> (s, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span> (s, <span class="number">1</span>, a[s]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Sb3 &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls p &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stree</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> l, r, val;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> l(x) St[x].l</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> r(x) St[x].r</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> v(x) St[x].val</span></span><br><span class="line">&#125; St[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span> (ls, l, mid), <span class="built_in">build</span> (rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> v, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) == <span class="built_in">r</span>(p)) &#123;</span><br><span class="line">    <span class="built_in">v</span>(p) += k; <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt;= mid) <span class="built_in">add</span> (ls, v, k);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">add</span> (rs, v, k);</span><br><span class="line">  <span class="built_in">v</span>(p) = <span class="built_in">v</span>(ls) + <span class="built_in">v</span>(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span> <span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">l</span>(p) &gt;= l &amp;&amp; <span class="built_in">r</span>(p) &lt;= r) <span class="keyword">return</span> <span class="built_in">v</span>(p);</span><br><span class="line">  <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">ask</span> (ls, l, r);</span><br><span class="line">  <span class="keyword">if</span> (r &gt; mid) ans += <span class="built_in">ask</span> (rs, l, r);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size[Maxn], fa[Maxn];</span><br><span class="line"><span class="keyword">int</span> dep[Maxn], son[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  size[x] = <span class="number">1</span>, fa[x] = f, dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y == f) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs1</span> (y, x);</span><br><span class="line">    size[x] += size[y];</span><br><span class="line">    <span class="keyword">if</span> (size[y] &gt; size[son[x]]) son[x] = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[Maxn], top[Maxn], tim;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  dfn[x] = ++tim, top[x] = f;</span><br><span class="line">  <span class="keyword">if</span> (son[x]) <span class="built_in">dfs2</span> (son[x], f);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = hd[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> y = e[i].v;</span><br><span class="line">    <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs2</span> (y, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (top[x] != <span class="number">1</span>) &#123;</span><br><span class="line">    ans += <span class="built_in">ask</span> (<span class="number">1</span>, dfn[top[x]], dfn[x]);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  ans += <span class="built_in">ask</span> (<span class="number">1</span>, <span class="number">1</span>, dfn[x]);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">dfs1</span> (<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">dfs2</span> (<span class="number">1</span>, <span class="number">1</span>), <span class="built_in">build</span> (<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> op = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> (), v = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="keyword">if</span> (dep[s] &amp; <span class="number">1</span>) <span class="built_in">add</span> (<span class="number">1</span>, dfn[s], v);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">add</span> (<span class="number">1</span>, dfn[s], -v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> s = <span class="built_in">read</span> ();</span><br><span class="line">      <span class="keyword">int</span> ans = <span class="built_in">query</span> (s);</span><br><span class="line">      <span class="keyword">if</span> (dep[s] &amp; <span class="number">1</span>) ans = ans + a[s];</span><br><span class="line">      <span class="keyword">else</span> ans = -ans + a[s];</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> (), m = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">read</span> (), y = <span class="built_in">read</span> ();</span><br><span class="line">    <span class="built_in">add</span> (x, y), <span class="built_in">add</span> (y, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">100</span> &amp;&amp; m &lt;= <span class="number">100</span>) Sb1::<span class="built_in">work</span> (m);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    Sb3::<span class="built_in">work</span> (n, m);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Data-Structure</tag>
        <tag>Summary</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-12-26 模拟赛总结</title>
    <url>/Home/solution-2021-12-26/</url>
    <content><![CDATA[<h1 id="2021-12-26-模拟赛总结"><a href="#2021-12-26-模拟赛总结" class="headerlink" title="2021-12-26 模拟赛总结"></a>2021-12-26 模拟赛总结</h1><p>貌似是 DP 专场呢 哭</p>
<span id="more"></span>
<h2 id="考场部分简结"><a href="#考场部分简结" class="headerlink" title="考场部分简结"></a>考场部分简结</h2><p>上来先看题，扫了一眼， $T1$ 贪心，$T2, T3$ 没看出来，再看 $T4$ ，这不关路灯吗？</p>
<p>处于对 DP 的恐惧，并没有先写 $T4$ ，先看 $T1$ ，写了半天发现假掉了，根据 S2OJ 数据原则，假贪心分低不了，再写 $T2$ ，$DP$ 想假了，真棒！打了爆搜走人。切了 $T4$ ，打了个 $T3$ $30’$ 状压，取整写错了，$30 -&gt; 10$ ，最终得分 : </p>
<script type="math/tex; mode=display">
50' + 40' + 10' + 100' = 200'</script><h2 id="题解部分"><a href="#题解部分" class="headerlink" title="题解部分"></a>题解部分</h2><h1 id="90岁的张哥哥"><a href="#90岁的张哥哥" class="headerlink" title="90岁的张哥哥"></a><a href="https://sjzezoj.com/contest/188/problem/1199">90岁的张哥哥</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $n$ 的序列和一个长度为 $m$ 的栈， 求字典序最小的出栈序。</p>
<h2 id="题目正解："><a href="#题目正解：" class="headerlink" title="题目正解："></a>题目正解：</h2><p>贪心 + 数据结构</p>
<h2 id="题目思路："><a href="#题目思路：" class="headerlink" title="题目思路："></a>题目思路：</h2><p>要进行 $k$ 次操作，每次操作重复几个步骤。</p>
<pre><code>1. 设当前区间 $[l, r]$ 中的最小元素的位置为 $x$ 。
2. 求出 $[x + 1, r]$ 的最小值，设为 $Min$。
3. 弹出当前栈顶直至 $stc[top] &gt; Min$ 。
4. 将 $[l, x - 1]$ 加入栈中，将 $l$ 设为 $x + 1$ ，$r = \min(r + 1, n)$  ，开始进行下一轮操作。
</code></pre><p>其中前 $m$ 个数和最后 $m$ 个数要进行特殊处理。</p>
<p>找最小值可以用线段树或者 $ST$ 表维护。</p>
<h2 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(nlogn)$ </p>
<h2 id="题目代码："><a href="#题目代码：" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], lg[Maxn], St[Maxn][<span class="number">30</span>], Min, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">St_init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  lg[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) lg[i] = lg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) St[i][<span class="number">0</span>] = a[i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ln = <span class="number">1</span>; ln &lt;= lg[n]; ++ln) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + (<span class="number">1</span> &lt;&lt; ln) - <span class="number">1</span> &lt;= n; ++l)</span><br><span class="line">      St[l][ln] = <span class="built_in">min</span>(St[l][ln - <span class="number">1</span>], St[l + (<span class="number">1</span> &lt;&lt; (ln - <span class="number">1</span>))][ln - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = lg[(r - l + <span class="number">1</span>)];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">min</span>(St[l][k], St[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stc[Maxn], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    a[i] = <span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">St_init</span>(n);</span><br><span class="line">  <span class="comment">// 特殊处理前 m 个数。</span></span><br><span class="line">  Min = <span class="built_in">query</span>(<span class="number">1</span>, m), x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == Min) &#123;</span><br><span class="line">      x = i; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stc[++top] = a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(a[x], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="comment">// 遍历序列，贪心</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = m + <span class="number">1</span>; r &lt;= n; ++r) &#123;</span><br><span class="line">    Min = <span class="built_in">query</span>(x + <span class="number">1</span>, r);            <span class="comment">// 求得最小值</span></span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; stc[top] &lt;= Min)    <span class="comment">// 和栈顶比较</span></span><br><span class="line">      <span class="built_in">print</span>(stc[top--], <span class="string">&#x27; &#x27;</span>);         <span class="comment">// 弹栈</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (x = x + <span class="number">1</span>; x &lt;= r; ++x) &#123;  <span class="comment">// 将 [l, x - 1] 加入栈中，同时找到 x</span></span><br><span class="line">        <span class="keyword">if</span> (a[x] == Min) &#123;</span><br><span class="line">          <span class="built_in">print</span>(a[x], <span class="string">&#x27; &#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stc[++top] = a[x];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 特殊处理后 m 个数。这里 i 只是单纯的枚举次数，不再有其他含义。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    Min = inf;</span><br><span class="line">    <span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n) Min = <span class="built_in">query</span>(x + <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; stc[top] &lt;= Min)</span><br><span class="line">      <span class="built_in">print</span>(stc[top--], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (x = x + <span class="number">1</span>; x &lt;= n; ++x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[x] == Min) &#123;</span><br><span class="line">          <span class="built_in">print</span>(a[x], <span class="string">&#x27; &#x27;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stc[++top] = a[x];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2016NOIP福建夏令营-迷宫"><a href="#2016NOIP福建夏令营-迷宫" class="headerlink" title="[2016NOIP福建夏令营]迷宫"></a><a href="https://sjzezoj.com/problem/1200">[2016NOIP福建夏令营]迷宫</a></h1><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个 $N\times N$ 的矩阵，每个格子内有且仅有大写字母。求从左上角只向右或向下走，并且路径是回文，最终到达右下角的方案数，对 $281474976710656$ 取模。</p>
<h2 id="题目正解：-1"><a href="#题目正解：-1" class="headerlink" title="题目正解："></a>题目正解：</h2><p>线性 DP</p>
<h2 id="题目思路：-1"><a href="#题目思路：-1" class="headerlink" title="题目思路："></a>题目思路：</h2><p>想要判断回文，常用的方法就是记录路径，但是发现这道题状态必然开不下。所以换一种思路。</p>
<p>如果想要走回文，可以抽象理解为你在左上角，我在右下角，你走一步，我走一步，且我们走的格子值必须相同，最终在中间某点交会。</p>
<p>就有点传纸条那味了。</p>
<p>可以发现想要记录状态，有以下几个要素：$x1, y2, x2, y2, i$ 其中 $i$ 为步数。</p>
<p>根据只能向右或向下走的规则，只需要记录 $k, x1, x2$ ，其他的信息就可以推知。</p>
<p>设 $f_{i, x1, x2}$ 表示一共走了 $i$ 步，两个人横坐标分别为 $x1, x2$ 的方案数。</p>
<p>枚举时，枚举甲和乙的步数 $i$，以及甲乙分别<strong>行走</strong>的横坐标数 $j, k$，常数 $sum$ 为从左上到右下的总步数，其他信息就可以推得：</p>
<script type="math/tex; mode=display">
x1 = j, y1 = i - x1, x2 = n - k + 1, y2 = sum - i - x2</script><p>转移方程细节较多，但挺直观，直接参见代码即可。</p>
<p>然后发现第一维可以滚动掉。</p>
<h2 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^3)$</p>
<h2 id="题目代码：-1"><a href="#题目代码：-1" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">281474976710656</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[Maxn][Maxn];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line">  f[<span class="number">0</span>][<span class="number">1</span>][n] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> sum = n * <span class="number">2</span> + <span class="number">2</span>, u = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    u ^= <span class="number">1</span>, <span class="built_in">memset</span> (f[u], <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span> (f[u]));                        <span class="comment">// 滚动数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; ++k) &#123;</span><br><span class="line">        <span class="keyword">int</span> X1 = j, Y1 = i - X1, X2 = n - k + <span class="number">1</span>, Y2 = sum - i - X2;		<span class="comment">// 计算坐标</span></span><br><span class="line">        <span class="keyword">if</span> (s[X1][Y1] != s[X2][Y2]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[X1][Y1 + <span class="number">1</span>] == s[X2][Y2 - <span class="number">1</span>])</span><br><span class="line">          (f[u][X1][X2] += f[u ^ <span class="number">1</span>][X1][X2]) %= P;                  <span class="comment">// 甲向下走，乙向上走</span></span><br><span class="line">        <span class="keyword">if</span> (s[X1 + <span class="number">1</span>][Y1] == s[X2 - <span class="number">1</span>][Y2])</span><br><span class="line">          (f[u][X1 + <span class="number">1</span>][X2 - <span class="number">1</span>] += f[u ^ <span class="number">1</span>][X1][X2]) %= P;          <span class="comment">// 甲向右走，乙向左走</span></span><br><span class="line">        <span class="keyword">if</span> (s[X1][Y1 + <span class="number">1</span>] == s[X2 - <span class="number">1</span>][Y2])</span><br><span class="line">          (f[u][X1][X2 - <span class="number">1</span>] += f[u ^ <span class="number">1</span>][X1][X2]) %= P;              <span class="comment">// 甲向下走，乙向左走</span></span><br><span class="line">        <span class="keyword">if</span> (s[X1 + <span class="number">1</span>][Y1] == s[X2][Y2 - <span class="number">1</span>])</span><br><span class="line">          (f[u][X1 + <span class="number">1</span>][X2] += f[u ^ <span class="number">1</span>][X1][X2]) %= P;              <span class="comment">// 甲向右走，乙向上走</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    (ans += f[u ^ <span class="number">1</span>][i][i]) %= P;                                   <span class="comment">// 统计总贡献</span></span><br><span class="line">  <span class="built_in">print</span> (ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="FJWC2017-恐狼后卫"><a href="#FJWC2017-恐狼后卫" class="headerlink" title="[FJWC2017]恐狼后卫"></a><a href="https://sjzezoj.com/problem/1201">[FJWC2017]恐狼后卫</a></h1><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有 $n$ 个手牌，每个手牌有三个属性 $a, b, h$ 表示这个手牌攻击力为 $a$ ，可以给旁边手牌攻击力加成为 $b$ ，生命值为 $b$ 。手牌生命值为 0 后自动消失，其他牌补位。</p>
<p>你的攻击力为 $m$ 。求击败所有手牌消耗的最小生命值。</p>
<h2 id="题目正解：-2"><a href="#题目正解：-2" class="headerlink" title="题目正解："></a>题目正解：</h2><p>区间 $DP$</p>
<h2 id="题目思路：-2"><a href="#题目思路：-2" class="headerlink" title="题目思路："></a>题目思路：</h2><p>拿到题第一反应没头绪，但数据范围不大，没思路那就区间 $DP$ 吧，区间 $DP$ 是个好东西。</p>
<p>设 $f_{l, r}$ 表示杀死区间 $[l ,r]$ 的最小花费，显然 $f_{l, l}$ 为 $(a_{l} + b_{l - 1} + b_{l + 1}) \times \left\lceil\dfrac{h_l}{m}\right\rceil$ 。</p>
<p>考虑枚举 $k$ ，表示先杀死 $[l, k - 1]$ 和 $[k + 1, r]$ 最后击杀 $k$ 的最小花费。</p>
<script type="math/tex; mode=display">
f_{l, r} = \min_{k = l}^{r}(f_{l, k - 1} + f_{k + 1, r} + (a_{k} + b_{l - 1} + b_{r + 1}) \times \left\lceil\dfrac{h_k}{m}\right\rceil)</script><h2 id="时间复杂度：-2"><a href="#时间复杂度：-2" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^3)$</p>
<h2 id="题目代码：-2"><a href="#题目代码：-2" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">namespace</span> IO  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">410</span>, inf = <span class="number">2e18</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wolf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a, b, h;</span><br><span class="line">&#125; x[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, f[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> kk = x[p].a + x[l].b + x[r].b;</span><br><span class="line">  <span class="keyword">return</span> (x[p].h + m - <span class="number">1</span>) / m * kk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span> (), m = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    x[i] = (Wolf) &#123;<span class="built_in">read</span> (), <span class="built_in">read</span> (), <span class="built_in">read</span> ()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">      f[i][j] = inf;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    f[i][i] = <span class="built_in">check</span> (i - <span class="number">1</span>, i, i + <span class="number">1</span>);													<span class="comment">// 初始化 DP 数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ln = <span class="number">2</span>; ln &lt;= n; ++ln) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + ln - <span class="number">1</span> &lt;= n; ++l) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = l + ln - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k) &#123;</span><br><span class="line">        f[l][r] = <span class="built_in">min</span> (f[l][r], f[l][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][r] + <span class="built_in">check</span> (l - <span class="number">1</span>, k, r + <span class="number">1</span>));	<span class="comment">// 枚举断点，转移</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span> (f[<span class="number">1</span>][n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Trainman’s-Travel"><a href="#Trainman’s-Travel" class="headerlink" title="Trainman’s Travel"></a><a href="https://sjzezoj.com/contest/188/problem/1202">Trainman’s Travel</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>有 $N + 1$ 个坐标，其中你的坐标为 $p$ ，你需要指定一个顺序，依次经过剩下的 $N$ 个点，求出最小<strong>时间和</strong>。</p>
<h2 id="题目正解：-3"><a href="#题目正解：-3" class="headerlink" title="题目正解："></a>题目正解：</h2><p>区间 $DP$</p>
<h2 id="题目思路：-3"><a href="#题目思路：-3" class="headerlink" title="题目思路："></a>题目思路：</h2><p>首先你发现这道题不能通过枚举断点来转移，因为走过 $l, r$ 所用的时间并不等价于 $[l, k]$ 和 $[k + 1, r]$ 的时间和。</p>
<p>考虑如果你经过了区间 $[l, r]$ 那么你在到 $l - 1$ 和 $r + 1$ 所用的时间是和你当前所在左右端点有关的。</p>
<p>所以考虑设状态 $f_{l, r, 0/1}$ 表示你走过了区间 $[l, r]$ ，你当前在左/右端点的最小时间。</p>
<p>这样转移就比较容易了。</p>
<script type="math/tex; mode=display">
f_{l, r, 0} = \min(f_{l + 1, r, 0} + (r - l + 1) \times (a_{l + 1} - a_l), f_{l + 1, r, 1} + (r - l + 1) \times (a_r - a_l))</script><script type="math/tex; mode=display">
f_{l, r, 1} = \min(f_{l, r - 1, 1} + (r - l + 1) \times (a_r - a_{r - 1}), f_{l, r - 1, 0} + (r - l + 1) \times (a_r - a_l))</script><h2 id="时间复杂度：-3"><a href="#时间复杂度：-3" class="headerlink" title="时间复杂度："></a>时间复杂度：</h2><p>$O(n^2)$</p>
<h2 id="题目代码：-3"><a href="#题目代码：-3" class="headerlink" title="题目代码："></a>题目代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code By CloudySky</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">namespace</span> IO &#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + (c ^ <span class="number">48</span>); c = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">  <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_n</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">9</span>) <span class="built_in">print_n</span>(x / <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> s = <span class="string">&#x27;\n&#x27;</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">  <span class="built_in">print_n</span>(x), <span class="built_in">putchar</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace IO</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> IO;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[Maxn], f[Maxn][Maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="built_in">read</span> (), p = <span class="built_in">read</span> ();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n + <span class="number">1</span>; ++l) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n + <span class="number">1</span>; ++r) &#123;</span><br><span class="line">      f[l][r][<span class="number">0</span>] = f[l][r][<span class="number">1</span>] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">    a[i] = <span class="built_in">read</span> ();</span><br><span class="line">  a[n + <span class="number">1</span>] = p;</span><br><span class="line">  <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">2</span>);</span><br><span class="line">  n = <span class="built_in">unique</span> (a + <span class="number">1</span>, a + n + <span class="number">2</span>) - a - <span class="number">1</span>;</span><br><span class="line">  p = <span class="built_in">lower_bound</span> (a + <span class="number">1</span>, a + n + n, p) - a;</span><br><span class="line">  f[p][p][<span class="number">0</span>] = f[p][p][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; ++l) &#123;</span><br><span class="line">      <span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">      f[l][r][<span class="number">0</span>] = <span class="built_in">min</span> (f[l + <span class="number">1</span>][r][<span class="number">0</span>] + (n - len + <span class="number">1</span>) * (a[l + <span class="number">1</span>] - a[l]), f[l + <span class="number">1</span>][r][<span class="number">1</span>] + (n - len + <span class="number">1</span>) * (a[r] - a[l]));</span><br><span class="line">      f[l][r][<span class="number">1</span>] = <span class="built_in">min</span> (f[l][r - <span class="number">1</span>][<span class="number">1</span>] + (n - len + <span class="number">1</span>) * (a[r] - a[r - <span class="number">1</span>]), f[l][r - <span class="number">1</span>][<span class="number">0</span>] + (n - len + <span class="number">1</span>) * (a[r] - a[l]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span> (<span class="built_in">min</span> (f[<span class="number">1</span>][n][<span class="number">0</span>], f[<span class="number">1</span>][n][<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题目总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Data-Structure</tag>
        <tag>Summary</tag>
        <tag>Greed</tag>
      </tags>
  </entry>
</search>
